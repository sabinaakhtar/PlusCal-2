/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. pcal.jj */
/*@egen*//**
 * JavaCC grammar for +CAL 2.0.
 * Copyright INRIA
 * BSD license
 * Authors: Sabina Akhtar, Stephan Merz, and Martin Quinson
 **/
options
{
	JDK_VERSION = "1.5";
	             
	                       

	// MQ: I use STATIC=false to turn of the tons of "static method should be accessed in a static way"
	//   errors that javac spits on the code generated by javacc without this.
	// It sounds like an easy bug of javacc, so it could get fixed one day.
	// We could just try turning this on again from time to time (after all, that the default value even if I've no idea of the impact).
	STATIC = false;
	//NODE_DEFAULT_VOID = true;

}
PARSER_BEGIN(pcal)

import java.io.*;

public class pcal/*@bgen(jjtree)*/implements pcalTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected JJTpcalState jjtree = new JJTpcalState();

/*@egen*/

	void jjtreeOpenNodeScope(Node n) {
		((SimpleNode)n).firstToken = getToken(1);
	}
	void jjtreeCloseNodeScope(Node n) {
		((SimpleNode)n).lastToken = getToken(0);
	}
	
	public static String test(String input, String name) 
		throws ParseException {
		
		InputStream in = new ByteArrayInputStream (input.getBytes());
		ByteArrayOutputStream out = new ByteArrayOutputStream();
		translate(in,out,name, "");
		return out.toString();
	}

	public static void translate(InputStream in, OutputStream out, String name, String arg1) 
		throws ParseException {
		
		pcal parser = new pcal(in);
		
		PcalTranslator translator = new PcalTranslator();
		PcalTLAGenerator generator = new PcalTLAGenerator();
		PcalNormalizer normalizer = new PcalNormalizer();
		ASTsourcefile nodes = null;
		st = new SymbolTable();    
		nodes = parser.sourcefile();
		System.out.println("Normalizing...");
		normalizer.start(nodes);

		boolean nowarning = false;
		if(arg1.equals("-nowarnings"))
			nowarning = true;
		
		System.out.println("Translating...");
		ExplodedTree tree = translator.start(nodes, nowarning);
		

		generator.start(tree, out, name);		

	}
	
	public static SymbolTable st;  
	public static void main(String args[]) throws java.io.IOException, ParseException {

		if (args.length < 1 || args.length > 2) {
			usage();
			System.exit(1);
		}
		else if(args.length == 2 && !args[1].equals("-nowarnings"))
		{
			usage();
			System.exit(1);
		}

		String fileName = new String();

		InputStream in = null;
		OutputStream out = null;
		
		try {
				in = new java.io.FileInputStream(args[0]);
				out = new ByteArrayOutputStream();
				if(args.length == 1)
					translate(in, out, args[0], "");
				else if(args.length == 2)
					translate(in, out, args[0], args[1]);
			} catch (java.io.FileNotFoundException e) {
				System.out.println("File " + args[0] + " not found, exiting.");
				System.exit(1);
			}		
 	}

	static void usage() {
		System.out.println("usage: java pcal <input file> <-nowarnings>");
	}

} // end class pcal

PARSER_END(pcal)

SKIP :
{
	" "
	| "\t"
	| "\n"
	| "\r"
}

// -------------------- comments (see JavaCC documentation) ----------------

SKIP :
{
		"(*" : WithinComment
}

	<WithinComment> SKIP :
	{
		<"*)"> : DEFAULT
	}

	<WithinComment> MORE:
	{
		< ~[] >
	}

	// -------------------- strings ----------------------------------------

	SKIP :
	{
		"\"" : WithinString
	}

	<WithinString> TOKEN :
	{
		<STRING:  "\"">  // delete trailing quotes
		{ matchedToken.image = image.toString().substring(0, image.length()-1); }
		: DEFAULT
	}

	<WithinString> MORE :
	{
		< ~["\"", "\n", "\r"] >
	}

	// -------------------- default token class ------------------------------

	TOKEN : /* keywords and separators */
	{
		< COMMA:         "," >
		| < SEMICOLON:     ";" >
		| < COLON:         ":" >
		| < DOT:           "." >
		| < AT:            "@" >
		| < UNDERSCORE:    "_" >
		| < ASSIGN:        ":=" >
		| < DEQ:           "==" >
		| < EQUAL:         "=" >
		| < NEQUAL:        "~=" >
		| < IN:            "\\in" >
		| < NOTIN:         "\\notin" >
		| < PARALLEL:      "||" >
		| < LPAR:          "(" >
		| < RPAR:          ")" >
		| < LBRAKK:        "[" >
		| < RBRAKK:        "]" >
		| < LBRACE:        "{" >
		| < RBRACE:        "}" >
		| < LTUPLE:        "<<" >
		| < RTUPLE:        ">>" >
		| < EXTENDS:       "extends" >
		| < ALGORITHM:     "algorithm" >
		| < VARIABLE:      "variable" | "variables" >
		| < DEF:           "def" >
		| < FUNCTION:      "function" >
		| < PROCEDURE:     "procedure" >
		| < DEFINITION:    "definition" >
		| < PROCESS:       "process" >
		| < THREAD:        "thread" >
		| < FAIR:          "fair" >
		| < STRONG:        "strong" | "strongly" >
		| < SYMMETRY:      "symmetric" >
		| < BEGIN:         "begin" >
		| < END:           "end" >
		| < PSKIP:         "skip" >
		| < ATOMIC:        "atomic" >
		| < IF:            "if" >
		| < ELSIF:         "elsif" >
		| < EITHER:        "either" >
		| < WHEN:          "when" >
		| < BRANCH:        "branch" >
		| < OR:            "or" >
		| < THEN:          "then" >
		| < ELSE:          "else" >
		| < LOOP:          "loop" >
		| < FOR:           "for" >
		| < WITH:          "with" >
		| < ASSERT:        "assert" >
		| < PRINT:         "print" >
		| < RETURN:        "return" >
		| < GOTO:          "goto" >
		| < BREAK:         "break" >
		| < RUN:           "run" >
		| < INVARIANT:     "invariant" >
		| < TEMPORAL:      "temporal" >
		| < CONSTANT:      "constant" | "constants" >
		| < CONSTRAINT:    "constraint" >
		| < SELF:          "self" >
		| < SUPER:          "super" >
	}

	TOKEN : /* expression syntax, including state formulas */
	{
		< TRUE :          "TRUE" >
		| < FALSE :         "FALSE" >
		| < BOOLEAN :       "BOOLEAN" >
		/*  | < LAND :          "/\\" >
  | < LOR :           "\\/" >*/
		| < LNOT :          "~" | "\\lnot" | "\\neg" >
		/*  | < LIMP :          "=>" >
  | < LEQUIV :        "<=>" | "\\equiv" >*/
		| < FORALL :        "\\A" >
		| < EXISTS :        "\\E" >
		| < CHOOSE :        "CHOOSE" >
		| < BOX :           "[]" >
		| < DIAMOND :       "<>" >
		| < EXCEPT :        "EXCEPT" >
		| < ARROW :         "->" >
		| < MAPSTO :        "|->" >
		| < BANG :          "!" >
		| < PSTRING :       "STRING" >
		| < EIF :           "IF" >      // conditional expressions
		| < ETHEN :         "THEN" >
		| < EELSE :         "ELSE" >
		| < ECASE :         "CASE" >
		| < EOTHER :        "OTHER" >
		| < LET :           "LET" >
		| < LETIN :         "IN" >
		| < DOMAIN :        "DOMAIN" >
		| < SUBSET :        "SUBSET" >
		| < UNION :         "UNION" >
		| < MINUS :         "-" >
		| < Main :         "Main" >
	}

	/*
SA:I moved the token NUMBER above the token NAME because the
lexical analyzer was creating token DIGIT for the numbers.
BUT, now it wont make a difference because i gave DIGIT a
local definition.
	 */
	TOKEN : /* numeric constants */
	{
		< NUMBER :  (<DIGIT>)+ ( "." (<DIGIT>)+ )? >
	}
	/*
SA:I changed the grammar for variables because in the previous
one, we could have a number or _ as a variable as well.
# is used to give local definitions.
	 */
	TOKEN : /* variables and labels */
	{
			< NAME:     ( <ALPHA> ( <ALPHA> | <DIGIT> | <OTHER> )* ) >
			| < #ALPHA:    ["a" - "z", "A" - "Z"] >
			| < #DIGIT:    ["0" - "9"] >
			| < #OTHER:    ["_"] >
	}

		//TOKEN : /* TLA+ prefix operators: cf. p.278 */
		//{
		//  <PREFIX:   "-" | <LNOT> | "DOMAIN" | "SUBSET" | "UNION" | /*<BOX> |*/ "<>" >
		//}

		TOKEN : /* TLA+ postfix operators: cf. p.278, except ',
           which is illegal in +CAL expressions */
		{
		<POSTFIX:  "^+" | "^*" | "^#" >
		}

	TOKEN : /* TLA+ infix operators: cf. p.278 */
	{
			<INFIX:   "$$$"  >
	}

		// ------------------------------ toplevel structure --------------------------
		ASTsourcefile sourcefile() :
		{/*@bgen(jjtree) sourcefile */
  ASTsourcefile jjtn000 = new ASTsourcefile(JJTSOURCEFILE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
		{/*@bgen(jjtree) sourcefile */
                        try {
/*@egen*/
			( model() )?
					( instance() )?
							<EOF>
			{ //st.showWarnings();
				System.out.println("Parsing complete.");
			}/*@bgen(jjtree)*/
                        {
                          jjtree.closeNodeScope(jjtn000, true);
                          jjtc000 = false;
                          jjtreeCloseNodeScope(jjtn000);
                        }
/*@egen*/
			{ return jjtn000; }/*@bgen(jjtree)*/
                        } catch (Throwable jjte000) {
                          if (jjtc000) {
                            jjtree.clearNodeScope(jjtn000);
                            jjtc000 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte000 instanceof RuntimeException) {
                            throw (RuntimeException)jjte000;
                          }
                          if (jjte000 instanceof ParseException) {
                            throw (ParseException)jjte000;
                          }
                          throw (Error)jjte000;
                        } finally {
                          if (jjtc000) {
                            jjtree.closeNodeScope(jjtn000, true);
                            jjtreeCloseNodeScope(jjtn000);
                          }
                        }
/*@egen*/
		}

		void model() :
		{/*@bgen(jjtree) model */
  ASTmodel jjtn000 = new ASTmodel(JJTMODEL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
		{/*@bgen(jjtree) model */
                        try {
/*@egen*/
			header()
			algorithm()/*@bgen(jjtree)*/
                        } catch (Throwable jjte000) {
                          if (jjtc000) {
                            jjtree.clearNodeScope(jjtn000);
                            jjtc000 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte000 instanceof RuntimeException) {
                            throw (RuntimeException)jjte000;
                          }
                          if (jjte000 instanceof ParseException) {
                            throw (ParseException)jjte000;
                          }
                          throw (Error)jjte000;
                        } finally {
                          if (jjtc000) {
                            jjtree.closeNodeScope(jjtn000, true);
                            jjtreeCloseNodeScope(jjtn000);
                          }
                        }
/*@egen*/
			//  footer()
		}

		/** TODO imports: to be defined
void header():
{}
{
  modelId()
  ( tlaModule() )*
  ( pcalModule() )*
}
		 */
		void header() :
		{/*@bgen(jjtree) header */
  ASTheader jjtn000 = new ASTheader(JJTHEADER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
		{/*@bgen(jjtree) header */
                        try {
/*@egen*/
			algorithmName()
			( header_extends() )?
					( header_constants() )?/*@bgen(jjtree)*/
                        } catch (Throwable jjte000) {
                          if (jjtc000) {
                            jjtree.clearNodeScope(jjtn000);
                            jjtc000 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte000 instanceof RuntimeException) {
                            throw (RuntimeException)jjte000;
                          }
                          if (jjte000 instanceof ParseException) {
                            throw (ParseException)jjte000;
                          }
                          throw (Error)jjte000;
                        } finally {
                          if (jjtc000) {
                            jjtree.closeNodeScope(jjtn000, true);
                            jjtreeCloseNodeScope(jjtn000);
                          }
                        }
/*@egen*/
		}

		void algorithmName() :
		{/*@bgen(jjtree) algorithmName */
                  ASTalgorithmName jjtn000 = new ASTalgorithmName(JJTALGORITHMNAME);
                  boolean jjtc000 = true;
                  jjtree.openNodeScope(jjtn000);
                  jjtreeOpenNodeScope(jjtn000);
/*@egen*/ Token t; }
		{/*@bgen(jjtree) algorithmName */
                        try {
/*@egen*/
			( <ALGORITHM> t = <NAME> )/*@bgen(jjtree)*/
                        {
                          jjtree.closeNodeScope(jjtn000, true);
                          jjtc000 = false;
                          jjtreeCloseNodeScope(jjtn000);
                        }
/*@egen*/
			{ 
				st.addSymbol(t.image, "algorithm", ""); 
				jjtn000.setName(t.image);
			}/*@bgen(jjtree)*/
                        } finally {
                          if (jjtc000) {
                            jjtree.closeNodeScope(jjtn000, true);
                            jjtreeCloseNodeScope(jjtn000);
                          }
                        }
/*@egen*/
		}

		void header_extends() :
		{/*@bgen(jjtree) header_extends */
  ASTheader_extends jjtn000 = new ASTheader_extends(JJTHEADER_EXTENDS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
		{/*@bgen(jjtree) header_extends */
                        try {
/*@egen*/
			<EXTENDS> <NAME> ( <COMMA> <NAME> )*/*@bgen(jjtree)*/
                        } finally {
                          if (jjtc000) {
                            jjtree.closeNodeScope(jjtn000, true);
                            jjtreeCloseNodeScope(jjtn000);
                          }
                        }
/*@egen*/
		}
		void header_constants() :
		{/*@bgen(jjtree) header_constants */
                  ASTheader_constants jjtn000 = new ASTheader_constants(JJTHEADER_CONSTANTS);
                  boolean jjtc000 = true;
                  jjtree.openNodeScope(jjtn000);
                  jjtreeOpenNodeScope(jjtn000);
/*@egen*/ Token t;}
		{/*@bgen(jjtree) header_constants */
                        try {
/*@egen*/
			<CONSTANT> 
			t = <NAME> 
			{ st.addSymbol(t.image, "constant", ""); }    
			( 
					<COMMA> 
					t = <NAME> 
					{ st.addSymbol(t.image, "constant", ""); } 
			)*/*@bgen(jjtree)*/
                        } finally {
                          if (jjtc000) {
                            jjtree.closeNodeScope(jjtn000, true);
                            jjtreeCloseNodeScope(jjtn000);
                          }
                        }
/*@egen*/ 
		}

		/* TODO
void footer()
{}
{
// what goes here????
}
		 */

		// ------------------------------ algorithm syntax --------------------------

		void algorithm() :
		{/*@bgen(jjtree) algorithm */
  ASTalgorithm jjtn000 = new ASTalgorithm(JJTALGORITHM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
		{/*@bgen(jjtree) algorithm */
                        try {
/*@egen*/
			declarations()
			( process() )*
			(
					<BEGIN>  // main code of algorithm
					statements()
			)?
					(LOOKAHEAD(3) <END> ( property() )+)?

							<END> ( <ALGORITHM> )?
									( property() )*/*@bgen(jjtree)*/
                        } catch (Throwable jjte000) {
                          if (jjtc000) {
                            jjtree.clearNodeScope(jjtn000);
                            jjtc000 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte000 instanceof RuntimeException) {
                            throw (RuntimeException)jjte000;
                          }
                          if (jjte000 instanceof ParseException) {
                            throw (ParseException)jjte000;
                          }
                          throw (Error)jjte000;
                        } finally {
                          if (jjtc000) {
                            jjtree.closeNodeScope(jjtn000, true);
                            jjtreeCloseNodeScope(jjtn000);
                          }
                        }
/*@egen*/

		}

		void process() :
		{/*@bgen(jjtree) process */
                  ASTprocess jjtn000 = new ASTprocess(JJTPROCESS);
                  boolean jjtc000 = true;
                  jjtree.openNodeScope(jjtn000);
                  jjtreeOpenNodeScope(jjtn000);
/*@egen*/ Token t; }
		{/*@bgen(jjtree) process */
                        try {
/*@egen*/
			symmetry()
			fairness()          {jjtreeOpenNodeScope(jjtn000);}
			<PROCESS> 
			t = <NAME>          { st.addSymbol(t.image, "process",""); }
			processHeader()       { st.checkExistenceAddMethod(t.image, "process", "line " + t.beginLine + ", column " + t.beginColumn); }

			declarations()
			( process() )*
			(
					<BEGIN>  // main code of process
					statements()
			)?
			(LOOKAHEAD(3) <END> ( property() )+)?
					<END> ( LOOKAHEAD(2) <PROCESS> )?  // end process vs. end \n process Foo
							propertySectionOutsideProcess()/*@bgen(jjtree)*/
                                                        {
                                                          jjtree.closeNodeScope(jjtn000, true);
                                                          jjtc000 = false;
                                                          jjtreeCloseNodeScope(jjtn000);
                                                        }
/*@egen*/
							{ st.popLastFrame(); }/*@bgen(jjtree)*/
                        } catch (Throwable jjte000) {
                          if (jjtc000) {
                            jjtree.clearNodeScope(jjtn000);
                            jjtc000 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte000 instanceof RuntimeException) {
                            throw (RuntimeException)jjte000;
                          }
                          if (jjte000 instanceof ParseException) {
                            throw (ParseException)jjte000;
                          }
                          throw (Error)jjte000;
                        } finally {
                          if (jjtc000) {
                            jjtree.closeNodeScope(jjtn000, true);
                            jjtreeCloseNodeScope(jjtn000);
                          }
                        }
/*@egen*/
		}
		void propertySectionOutsideProcess() :
		{/*@bgen(jjtree) propertySectionOutsideProcess */
  ASTpropertySectionOutsideProcess jjtn000 = new ASTpropertySectionOutsideProcess(JJTPROPERTYSECTIONOUTSIDEPROCESS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
		{/*@bgen(jjtree) propertySectionOutsideProcess */
                        try {
/*@egen*/
			( property() )*/*@bgen(jjtree)*/
                        } catch (Throwable jjte000) {
                          if (jjtc000) {
                            jjtree.clearNodeScope(jjtn000);
                            jjtc000 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte000 instanceof RuntimeException) {
                            throw (RuntimeException)jjte000;
                          }
                          if (jjte000 instanceof ParseException) {
                            throw (ParseException)jjte000;
                          }
                          throw (Error)jjte000;
                        } finally {
                          if (jjtc000) {
                            jjtree.closeNodeScope(jjtn000, true);
                            jjtreeCloseNodeScope(jjtn000);
                          }
                        }
/*@egen*/
		}
		/*
void thread() :
{ Token t; }
{
  symmetry()
  fairness()
  <THREAD> 
  t = <NAME> 
  { st.addSymbol(t.image, "thread", ""); }
  ( paramDecls() )?
  declarations()
  <BEGIN>  // main code of thread
  statements()
  <END> ( LOOKAHEAD(2) <THREAD> )?  // end thread vs. end \n thread Bar
  ( property() )*
  { st.popLastFrame(); }
}
		 */
		// ------------------------------ declarations -----------------------------

		void declarations() :
		{/*@bgen(jjtree) declarations */
  ASTdeclarations jjtn000 = new ASTdeclarations(JJTDECLARATIONS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
		{/*@bgen(jjtree) declarations */
                        try {
/*@egen*/
			(
					varDecls()
					|
					defDecl()
					|
					functDecl()
			)*/*@bgen(jjtree)*/
                        } catch (Throwable jjte000) {
                          if (jjtc000) {
                            jjtree.clearNodeScope(jjtn000);
                            jjtc000 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte000 instanceof RuntimeException) {
                            throw (RuntimeException)jjte000;
                          }
                          if (jjte000 instanceof ParseException) {
                            throw (ParseException)jjte000;
                          }
                          throw (Error)jjte000;
                        } finally {
                          if (jjtc000) {
                            jjtree.closeNodeScope(jjtn000, true);
                            jjtreeCloseNodeScope(jjtn000);
                          }
                        }
/*@egen*/
		}

		void varDecls():
		{/*@bgen(jjtree) varDecls */
  ASTvarDecls jjtn000 = new ASTvarDecls(JJTVARDECLS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
		{/*@bgen(jjtree) varDecls */
                        try {
/*@egen*/
			<VARIABLE>
			varDecl()
			( <COMMA> varDecl() )*/*@bgen(jjtree)*/
                        } catch (Throwable jjte000) {
                          if (jjtc000) {
                            jjtree.clearNodeScope(jjtn000);
                            jjtc000 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte000 instanceof RuntimeException) {
                            throw (RuntimeException)jjte000;
                          }
                          if (jjte000 instanceof ParseException) {
                            throw (ParseException)jjte000;
                          }
                          throw (Error)jjte000;
                        } finally {
                          if (jjtc000) {
                            jjtree.closeNodeScope(jjtn000, true);
                            jjtreeCloseNodeScope(jjtn000);
                          }
                        }
/*@egen*/
		}

		void varDecl() :
		{/*@bgen(jjtree) varDecl */
                        ASTvarDecl jjtn000 = new ASTvarDecl(JJTVARDECL);
                        boolean jjtc000 = true;
                        jjtree.openNodeScope(jjtn000);
                        jjtreeOpenNodeScope(jjtn000);
/*@egen*/
			Token t;
		}
		{/*@bgen(jjtree) varDecl */
                        try {
/*@egen*/
			t = <NAME>
			{ st.addSymbol(t.image, "variable", ""); jjtn000.setName(t.image);}    
			( <EQUAL> expression() )?/*@bgen(jjtree)*/
                        } catch (Throwable jjte000) {
                          if (jjtc000) {
                            jjtree.clearNodeScope(jjtn000);
                            jjtc000 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte000 instanceof RuntimeException) {
                            throw (RuntimeException)jjte000;
                          }
                          if (jjte000 instanceof ParseException) {
                            throw (ParseException)jjte000;
                          }
                          throw (Error)jjte000;
                        } finally {
                          if (jjtc000) {
                            jjtree.closeNodeScope(jjtn000, true);
                            jjtreeCloseNodeScope(jjtn000);
                          }
                        }
/*@egen*/   // must be constant expression
		}

		void processHeader():
		{/*@bgen(jjtree) processHeader */
                  ASTprocessHeader jjtn000 = new ASTprocessHeader(JJTPROCESSHEADER);
                  boolean jjtc000 = true;
                  jjtree.openNodeScope(jjtn000);
                  jjtreeOpenNodeScope(jjtn000);
/*@egen*/ Token t; }
		{/*@bgen(jjtree) processHeader */
                        try {
/*@egen*/
			<LBRAKK>
			expression()
			// {st.checkDeclaration(t.image, "variable", 0, "line " + t.beginLine + ", column " + t.beginColumn);} )
			<RBRAKK>/*@bgen(jjtree)*/
                        } catch (Throwable jjte000) {
                          if (jjtc000) {
                            jjtree.clearNodeScope(jjtn000);
                            jjtc000 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte000 instanceof RuntimeException) {
                            throw (RuntimeException)jjte000;
                          }
                          if (jjte000 instanceof ParseException) {
                            throw (ParseException)jjte000;
                          }
                          throw (Error)jjte000;
                        } finally {
                          if (jjtc000) {
                            jjtree.closeNodeScope(jjtn000, true);
                            jjtreeCloseNodeScope(jjtn000);
                          }
                        }
/*@egen*/
			//    ( <EQUAL> expression() )
			//    |
			//    ( <IN> expression() )
		}

		void processDeclSetExpression()       :
		{}
		{
			<LBRACE>
			(
					expression()
					(
							setEnumeration()
					)?
			)?
					<RBRACE>
		}

		void defDecl() :
		{/*@bgen(jjtree) defDecl */
                        ASTdefDecl jjtn000 = new ASTdefDecl(JJTDEFDECL);
                        boolean jjtc000 = true;
                        jjtree.openNodeScope(jjtn000);
                        jjtreeOpenNodeScope(jjtn000);
/*@egen*/
			Token t;
		}
		{/*@bgen(jjtree) defDecl */
                        try {
/*@egen*/
			<DEFINITION>
			t = <NAME>
			{ st.addSymbol(t.image, "definition", ""); }
			( paramDecls() )?
					{ st.checkExistenceAddMethod(t.image, "definition", "line " + t.beginLine + ", column " + t.beginColumn); }
			<DEQ>
			expression()
			( <SEMICOLON> )?/*@bgen(jjtree)*/
                                        {
                                          jjtree.closeNodeScope(jjtn000, true);
                                          jjtc000 = false;
                                          jjtreeCloseNodeScope(jjtn000);
                                        }
/*@egen*/
					{ st.popLastFrame(); }/*@bgen(jjtree)*/
                        } catch (Throwable jjte000) {
                          if (jjtc000) {
                            jjtree.clearNodeScope(jjtn000);
                            jjtc000 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte000 instanceof RuntimeException) {
                            throw (RuntimeException)jjte000;
                          }
                          if (jjte000 instanceof ParseException) {
                            throw (ParseException)jjte000;
                          }
                          throw (Error)jjte000;
                        } finally {
                          if (jjtc000) {
                            jjtree.closeNodeScope(jjtn000, true);
                            jjtreeCloseNodeScope(jjtn000);
                          }
                        }
/*@egen*/
		}

		void functDecl() :
		{/*@bgen(jjtree) functDecl */
                        ASTfunctDecl jjtn000 = new ASTfunctDecl(JJTFUNCTDECL);
                        boolean jjtc000 = true;
                        jjtree.openNodeScope(jjtn000);
                        jjtreeOpenNodeScope(jjtn000);
/*@egen*/
			Token t,t_func_proc;
		}
		{/*@bgen(jjtree) functDecl */
                        try {
/*@egen*/
			(t_func_proc = <PROCEDURE> )
			t = <NAME>
			{ st.addSymbol(t.image, t_func_proc.image, ""); }
			paramDecls()
			{ st.checkExistenceAddMethod(t.image, t_func_proc.image, "line " + t.beginLine + ", column " + t.beginColumn); }
			( varDecls() )?
					<BEGIN>  // main code of function
			statements()
			<END> ( LOOKAHEAD(2) (<PROCEDURE>) )?/*@bgen(jjtree)*/
                                        {
                                          jjtree.closeNodeScope(jjtn000, true);
                                          jjtc000 = false;
                                          jjtreeCloseNodeScope(jjtn000);
                                        }
/*@egen*/  // end procedure vs. end \n procedure g()
					{ st.popLastFrame(); }/*@bgen(jjtree)*/
                        } catch (Throwable jjte000) {
                          if (jjtc000) {
                            jjtree.clearNodeScope(jjtn000);
                            jjtc000 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte000 instanceof RuntimeException) {
                            throw (RuntimeException)jjte000;
                          }
                          if (jjte000 instanceof ParseException) {
                            throw (ParseException)jjte000;
                          }
                          throw (Error)jjte000;
                        } finally {
                          if (jjtc000) {
                            jjtree.closeNodeScope(jjtn000, true);
                            jjtreeCloseNodeScope(jjtn000);
                          }
                        }
/*@egen*/
		}

		void paramDecls():
		{/*@bgen(jjtree) paramDecls */
  ASTparamDecls jjtn000 = new ASTparamDecls(JJTPARAMDECLS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
		{/*@bgen(jjtree) paramDecls */
                        try {
/*@egen*/
			<LPAR>
			( paramDecl()
					( <COMMA> paramDecl() )*
			)?
					<RPAR>/*@bgen(jjtree)*/
                        } catch (Throwable jjte000) {
                          if (jjtc000) {
                            jjtree.clearNodeScope(jjtn000);
                            jjtc000 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte000 instanceof RuntimeException) {
                            throw (RuntimeException)jjte000;
                          }
                          if (jjte000 instanceof ParseException) {
                            throw (ParseException)jjte000;
                          }
                          throw (Error)jjte000;
                        } finally {
                          if (jjtc000) {
                            jjtree.closeNodeScope(jjtn000, true);
                            jjtreeCloseNodeScope(jjtn000);
                          }
                        }
/*@egen*/
		}

		void paramDecl() :
		{/*@bgen(jjtree) paramDecl */
                  ASTparamDecl jjtn000 = new ASTparamDecl(JJTPARAMDECL);
                  boolean jjtc000 = true;
                  jjtree.openNodeScope(jjtn000);
                  jjtreeOpenNodeScope(jjtn000);
/*@egen*/ Token t; }
		{/*@bgen(jjtree) paramDecl */
                        try {
/*@egen*/
			t = <NAME>
			{ st.addSymbol(t.image, "parameter", ""); }  
			( <DEQ> expression() )?/*@bgen(jjtree)*/
                        } catch (Throwable jjte000) {
                          if (jjtc000) {
                            jjtree.clearNodeScope(jjtn000);
                            jjtc000 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte000 instanceof RuntimeException) {
                            throw (RuntimeException)jjte000;
                          }
                          if (jjte000 instanceof ParseException) {
                            throw (ParseException)jjte000;
                          }
                          throw (Error)jjte000;
                        } finally {
                          if (jjtc000) {
                            jjtree.closeNodeScope(jjtn000, true);
                            jjtreeCloseNodeScope(jjtn000);
                          }
                        }
/*@egen*/      // must be constant expression

		}

		int paramInstances() :
		{/*@bgen(jjtree) paramInstances */
                        ASTparamInstances jjtn000 = new ASTparamInstances(JJTPARAMINSTANCES);
                        boolean jjtc000 = true;
                        jjtree.openNodeScope(jjtn000);
                        jjtreeOpenNodeScope(jjtn000);
/*@egen*/
			int noofparameters = 0;
		}
		{/*@bgen(jjtree) paramInstances */
                        try {
/*@egen*/
			<LPAR>
			( paramInstance()
					{noofparameters = 1; }
			( <COMMA> paramInstance() { noofparameters++; } )*
			)?
					<RPAR>/*@bgen(jjtree)*/
                        {
                          jjtree.closeNodeScope(jjtn000, true);
                          jjtc000 = false;
                          jjtreeCloseNodeScope(jjtn000);
                        }
/*@egen*/
			{ return noofparameters; }/*@bgen(jjtree)*/
                        } catch (Throwable jjte000) {
                          if (jjtc000) {
                            jjtree.clearNodeScope(jjtn000);
                            jjtc000 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte000 instanceof RuntimeException) {
                            throw (RuntimeException)jjte000;
                          }
                          if (jjte000 instanceof ParseException) {
                            throw (ParseException)jjte000;
                          }
                          throw (Error)jjte000;
                        } finally {
                          if (jjtc000) {
                            jjtree.closeNodeScope(jjtn000, true);
                            jjtreeCloseNodeScope(jjtn000);
                          }
                        }
/*@egen*/
		}

		void paramInstance() :
		{/*@bgen(jjtree) paramInstance */
                  ASTparamInstance jjtn000 = new ASTparamInstance(JJTPARAMINSTANCE);
                  boolean jjtc000 = true;
                  jjtree.openNodeScope(jjtn000);
                  jjtreeOpenNodeScope(jjtn000);
/*@egen*/ Token t; }
		{/*@bgen(jjtree) paramInstance */
                        try {
/*@egen*/
			( LOOKAHEAD(2)   // distinguish expression foo from foo == 5
					t = <NAME> <DEQ> 
			{ st.checkDeclaration(t.image, "variable", 0, "line " + t.beginLine + ", column " + t.beginColumn); }
			)?
					expression()/*@bgen(jjtree)*/
                        } catch (Throwable jjte000) {
                          if (jjtc000) {
                            jjtree.clearNodeScope(jjtn000);
                            jjtc000 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte000 instanceof RuntimeException) {
                            throw (RuntimeException)jjte000;
                          }
                          if (jjte000 instanceof ParseException) {
                            throw (ParseException)jjte000;
                          }
                          throw (Error)jjte000;
                        } finally {
                          if (jjtc000) {
                            jjtree.closeNodeScope(jjtn000, true);
                            jjtreeCloseNodeScope(jjtn000);
                          }
                        }
/*@egen*/
		}
		// --------------------------Try Definitions--------------------------------

		void PREFIX() :
		{/*@bgen(jjtree) PREFIX */
  ASTPREFIX jjtn000 = new ASTPREFIX(JJTPREFIX);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
		{/*@bgen(jjtree) PREFIX */
                        try {
/*@egen*/
			<MINUS> | <LNOT> | <DOMAIN> | <SUBSET> | <UNION> | <BOX> | <DIAMOND>/*@bgen(jjtree)*/
                        } finally {
                          if (jjtc000) {
                            jjtree.closeNodeScope(jjtn000, true);
                            jjtreeCloseNodeScope(jjtn000);
                          }
                        }
/*@egen*/ 
		}

		// ------------------------------ statements ----------------------------

		void statements() : // non-null sequence of statements separated by ";"
		{/*@bgen(jjtree) statements */
  ASTstatements jjtn000 = new ASTstatements(JJTSTATEMENTS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
		{/*@bgen(jjtree) statements */
                        try {
/*@egen*/
			statement()
			( LOOKAHEAD(2)  // optional semicolon at end of list generates choice conflict
					<SEMICOLON>
			statement()
			)*
			( <SEMICOLON> )?/*@bgen(jjtree)*/
                        } catch (Throwable jjte000) {
                          if (jjtc000) {
                            jjtree.clearNodeScope(jjtn000);
                            jjtc000 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte000 instanceof RuntimeException) {
                            throw (RuntimeException)jjte000;
                          }
                          if (jjte000 instanceof ParseException) {
                            throw (ParseException)jjte000;
                          }
                          throw (Error)jjte000;
                        } finally {
                          if (jjtc000) {
                            jjtree.closeNodeScope(jjtn000, true);
                            jjtreeCloseNodeScope(jjtn000);
                          }
                        }
/*@egen*/
		}

		void statement() :
		{/*@bgen(jjtree) statement */
                 ASTstatement jjtn000 = new ASTstatement(JJTSTATEMENT);
                 boolean jjtc000 = true;
                 jjtree.openNodeScope(jjtn000);
                 jjtreeOpenNodeScope(jjtn000);
/*@egen*/Token t = null;}
		{/*@bgen(jjtree) statement */
                        try {
/*@egen*/
			( LOOKAHEAD(2)   // distinguish foo : stmt from foo := bar+1
					fairness()
					t = <NAME>   // label
			{ st.checkLabelExistence(t.image); } 
			<COLON>
			)?
					instruction()/*@bgen(jjtree)*/
                        } catch (Throwable jjte000) {
                          if (jjtc000) {
                            jjtree.clearNodeScope(jjtn000);
                            jjtc000 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte000 instanceof RuntimeException) {
                            throw (RuntimeException)jjte000;
                          }
                          if (jjte000 instanceof ParseException) {
                            throw (ParseException)jjte000;
                          }
                          throw (Error)jjte000;
                        } finally {
                          if (jjtc000) {
                            jjtree.closeNodeScope(jjtn000, true);
                            jjtreeCloseNodeScope(jjtn000);
                          }
                        }
/*@egen*/

		}

		void instruction() :
		{/*@bgen(jjtree) instruction */
  ASTinstruction jjtn000 = new ASTinstruction(JJTINSTRUCTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
		{/*@bgen(jjtree) instruction */
                        try {
/*@egen*/
			skip()
			| atomic()
			| LOOKAHEAD(2)  // distinguish f(x,y) from f := x+1
			procedureCall()
			| assign()
			| branch()
			| ifelse()
			| when()
			| either()
			| loop()
			| foreach()
			| with()
			| pAssert()
			| print()
			| pReturn()
			| pGoto()
			| pBreak()/*@bgen(jjtree)*/
                        } catch (Throwable jjte000) {
                          if (jjtc000) {
                            jjtree.clearNodeScope(jjtn000);
                            jjtc000 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte000 instanceof RuntimeException) {
                            throw (RuntimeException)jjte000;
                          }
                          if (jjte000 instanceof ParseException) {
                            throw (ParseException)jjte000;
                          }
                          throw (Error)jjte000;
                        } finally {
                          if (jjtc000) {
                            jjtree.closeNodeScope(jjtn000, true);
                            jjtreeCloseNodeScope(jjtn000);
                          }
                        }
/*@egen*/
		}

		void skip() :
		{/*@bgen(jjtree) skip */
  ASTskip jjtn000 = new ASTskip(JJTSKIP);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
		{/*@bgen(jjtree) skip */
                        try {
/*@egen*/
			<PSKIP>/*@bgen(jjtree)*/
                        } finally {
                          if (jjtc000) {
                            jjtree.closeNodeScope(jjtn000, true);
                            jjtreeCloseNodeScope(jjtn000);
                          }
                        }
/*@egen*/
		}

		void atomic() :
		{/*@bgen(jjtree) atomic */
  ASTatomic jjtn000 = new ASTatomic(JJTATOMIC);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
		{/*@bgen(jjtree) atomic */
                        try {
/*@egen*/
			<ATOMIC>
			statements()
			<END> ( <ATOMIC> )?/*@bgen(jjtree)*/
                        } catch (Throwable jjte000) {
                          if (jjtc000) {
                            jjtree.clearNodeScope(jjtn000);
                            jjtc000 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte000 instanceof RuntimeException) {
                            throw (RuntimeException)jjte000;
                          }
                          if (jjte000 instanceof ParseException) {
                            throw (ParseException)jjte000;
                          }
                          throw (Error)jjte000;
                        } finally {
                          if (jjtc000) {
                            jjtree.closeNodeScope(jjtn000, true);
                            jjtreeCloseNodeScope(jjtn000);
                          }
                        }
/*@egen*/
		}

		void assign()       :
		{}
		{
			assignSingle()
			(
					<PARALLEL>
					assignSingle()
			)*
		}

		void assignSingle() :
		{/*@bgen(jjtree) assignSingle */
  ASTassignSingle jjtn000 = new ASTassignSingle(JJTASSIGNSINGLE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
		{/*@bgen(jjtree) assignSingle */
                        try {
/*@egen*/
			assignLHS()
			<ASSIGN>
			(
					expression()
					|
					run()       // run process and assign ID to variable
			)/*@bgen(jjtree)*/
                        } catch (Throwable jjte000) {
                          if (jjtc000) {
                            jjtree.clearNodeScope(jjtn000);
                            jjtc000 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte000 instanceof RuntimeException) {
                            throw (RuntimeException)jjte000;
                          }
                          if (jjte000 instanceof ParseException) {
                            throw (ParseException)jjte000;
                          }
                          throw (Error)jjte000;
                        } finally {
                          if (jjtc000) {
                            jjtree.closeNodeScope(jjtn000, true);
                            jjtreeCloseNodeScope(jjtn000);
                          }
                        }
/*@egen*/
		}

		void assignLHS() :
		{/*@bgen(jjtree) assignLHS */
                        ASTassignLHS jjtn000 = new ASTassignLHS(JJTASSIGNLHS);
                        boolean jjtc000 = true;
                        jjtree.openNodeScope(jjtn000);
                        jjtreeOpenNodeScope(jjtn000);
/*@egen*/
			Token t;
		}
		{/*@bgen(jjtree) assignLHS */
                        try {
/*@egen*/
			t = <NAME>      // verify definedness of variable in current scope
			{
				//commented to change warning stage
				st.checkDeclaration(t.image, "variable", 0, "line " + t.beginLine + ", column " + t.beginColumn);
			}
			( selector() )*/*@bgen(jjtree)*/
                        } catch (Throwable jjte000) {
                          if (jjtc000) {
                            jjtree.clearNodeScope(jjtn000);
                            jjtc000 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte000 instanceof RuntimeException) {
                            throw (RuntimeException)jjte000;
                          }
                          if (jjte000 instanceof ParseException) {
                            throw (ParseException)jjte000;
                          }
                          throw (Error)jjte000;
                        } finally {
                          if (jjtc000) {
                            jjtree.closeNodeScope(jjtn000, true);
                            jjtreeCloseNodeScope(jjtn000);
                          }
                        }
/*@egen*/
		}

		void selector() :
		{/*@bgen(jjtree) selector */
  ASTselector jjtn000 = new ASTselector(JJTSELECTOR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
		{/*@bgen(jjtree) selector */
                        try {
/*@egen*/
			( // array selector
					<LBRAKK>
					expression()
					(
							<COMMA>
							expression()
					)*
					<RBRAKK>
			)
			|
			( // record selector
					<DOT>
					<NAME>
			)/*@bgen(jjtree)*/
                        } catch (Throwable jjte000) {
                          if (jjtc000) {
                            jjtree.clearNodeScope(jjtn000);
                            jjtc000 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte000 instanceof RuntimeException) {
                            throw (RuntimeException)jjte000;
                          }
                          if (jjte000 instanceof ParseException) {
                            throw (ParseException)jjte000;
                          }
                          throw (Error)jjte000;
                        } finally {
                          if (jjtc000) {
                            jjtree.closeNodeScope(jjtn000, true);
                            jjtreeCloseNodeScope(jjtn000);
                          }
                        }
/*@egen*/
		}
		void ifelse() :
		{/*@bgen(jjtree) ifelse */
  ASTifelse jjtn000 = new ASTifelse(JJTIFELSE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
		{/*@bgen(jjtree) ifelse */
                        try {
/*@egen*/
			<IF>
			branchArm()
			(
					LOOKAHEAD(2)
					(<ELSE> <IF> | <ELSIF>)
					branchArm()
			)*
			(
					<ELSE>
					statements()
			)?
					<END> ( <IF> )?/*@bgen(jjtree)*/
                        } catch (Throwable jjte000) {
                          if (jjtc000) {
                            jjtree.clearNodeScope(jjtn000);
                            jjtc000 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte000 instanceof RuntimeException) {
                            throw (RuntimeException)jjte000;
                          }
                          if (jjte000 instanceof ParseException) {
                            throw (ParseException)jjte000;
                          }
                          throw (Error)jjte000;
                        } finally {
                          if (jjtc000) {
                            jjtree.closeNodeScope(jjtn000, true);
                            jjtreeCloseNodeScope(jjtn000);
                          }
                        }
/*@egen*/
		}
		void when() :
		{/*@bgen(jjtree) when */
  ASTwhen jjtn000 = new ASTwhen(JJTWHEN);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
		{/*@bgen(jjtree) when */
                        try {
/*@egen*/
			<WHEN> expression()/*@bgen(jjtree)*/
                        } catch (Throwable jjte000) {
                          if (jjtc000) {
                            jjtree.clearNodeScope(jjtn000);
                            jjtc000 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte000 instanceof RuntimeException) {
                            throw (RuntimeException)jjte000;
                          }
                          if (jjte000 instanceof ParseException) {
                            throw (ParseException)jjte000;
                          }
                          throw (Error)jjte000;
                        } finally {
                          if (jjtc000) {
                            jjtree.closeNodeScope(jjtn000, true);
                            jjtreeCloseNodeScope(jjtn000);
                          }
                        }
/*@egen*/
		}
		void either() :
		{/*@bgen(jjtree) either */
  ASTeither jjtn000 = new ASTeither(JJTEITHER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
		{/*@bgen(jjtree) either */
                        try {
/*@egen*/
			<EITHER>
			statements()
			(
					<OR>
					statements()
			)*
			<END> ( <EITHER> )?/*@bgen(jjtree)*/
                        } catch (Throwable jjte000) {
                          if (jjtc000) {
                            jjtree.clearNodeScope(jjtn000);
                            jjtc000 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte000 instanceof RuntimeException) {
                            throw (RuntimeException)jjte000;
                          }
                          if (jjte000 instanceof ParseException) {
                            throw (ParseException)jjte000;
                          }
                          throw (Error)jjte000;
                        } finally {
                          if (jjtc000) {
                            jjtree.closeNodeScope(jjtn000, true);
                            jjtreeCloseNodeScope(jjtn000);
                          }
                        }
/*@egen*/
		}
		void branch() :
		{/*@bgen(jjtree) branch */
  ASTbranch jjtn000 = new ASTbranch(JJTBRANCH);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
		{/*@bgen(jjtree) branch */
                        try {
/*@egen*/
			<BRANCH>
			branchArm()
			(
					<OR>
					branchArm()
			)*

			(
					<ELSE>
					statements()
					//    <END>
			)?
					<END> ( <BRANCH> )?/*@bgen(jjtree)*/
                        } catch (Throwable jjte000) {
                          if (jjtc000) {
                            jjtree.clearNodeScope(jjtn000);
                            jjtc000 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte000 instanceof RuntimeException) {
                            throw (RuntimeException)jjte000;
                          }
                          if (jjte000 instanceof ParseException) {
                            throw (ParseException)jjte000;
                          }
                          throw (Error)jjte000;
                        } finally {
                          if (jjtc000) {
                            jjtree.closeNodeScope(jjtn000, true);
                            jjtreeCloseNodeScope(jjtn000);
                          }
                        }
/*@egen*/
		}

		void branchArm() :
		{/*@bgen(jjtree) branchArm */
  ASTbranchArm jjtn000 = new ASTbranchArm(JJTBRANCHARM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
		{/*@bgen(jjtree) branchArm */
                        try {
/*@egen*/
			expression()
			<THEN>
			statements()/*@bgen(jjtree)*/
                        } catch (Throwable jjte000) {
                          if (jjtc000) {
                            jjtree.clearNodeScope(jjtn000);
                            jjtc000 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte000 instanceof RuntimeException) {
                            throw (RuntimeException)jjte000;
                          }
                          if (jjte000 instanceof ParseException) {
                            throw (ParseException)jjte000;
                          }
                          throw (Error)jjte000;
                        } finally {
                          if (jjtc000) {
                            jjtree.closeNodeScope(jjtn000, true);
                            jjtreeCloseNodeScope(jjtn000);
                          }
                        }
/*@egen*/
			//  <END>
		}

		void loop() :
		{/*@bgen(jjtree) loop */
  ASTloop jjtn000 = new ASTloop(JJTLOOP);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
		{/*@bgen(jjtree) loop */
                        try {
/*@egen*/
			<LOOP>
			statements()
			<END> ( <LOOP> )?/*@bgen(jjtree)*/
                        } catch (Throwable jjte000) {
                          if (jjtc000) {
                            jjtree.clearNodeScope(jjtn000);
                            jjtc000 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte000 instanceof RuntimeException) {
                            throw (RuntimeException)jjte000;
                          }
                          if (jjte000 instanceof ParseException) {
                            throw (ParseException)jjte000;
                          }
                          throw (Error)jjte000;
                        } finally {
                          if (jjtc000) {
                            jjtree.closeNodeScope(jjtn000, true);
                            jjtreeCloseNodeScope(jjtn000);
                          }
                        }
/*@egen*/
		}

		void foreach() :
		{/*@bgen(jjtree) foreach */
                        ASTforeach jjtn000 = new ASTforeach(JJTFOREACH);
                        boolean jjtc000 = true;
                        jjtree.openNodeScope(jjtn000);
                        jjtreeOpenNodeScope(jjtn000);
/*@egen*/
			Token t;
		}
		{/*@bgen(jjtree) foreach */
                        try {
/*@egen*/
			<FOR> 
			t = <NAME> 
			{ st.addSymbol(t.image, "variable", ""); }
			//{ st.checkDeclaration(t.image, "variable", 0, "line " + t.beginLine + ", column " + t.beginColumn); }
			<IN> expression()
			statements()
			<END> ( <FOR> )?/*@bgen(jjtree)*/
                                        {
                                          jjtree.closeNodeScope(jjtn000, true);
                                          jjtc000 = false;
                                          jjtreeCloseNodeScope(jjtn000);
                                        }
/*@egen*/
					{ st.removeAuxVariable(t.image); }/*@bgen(jjtree)*/
                        } catch (Throwable jjte000) {
                          if (jjtc000) {
                            jjtree.clearNodeScope(jjtn000);
                            jjtc000 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte000 instanceof RuntimeException) {
                            throw (RuntimeException)jjte000;
                          }
                          if (jjte000 instanceof ParseException) {
                            throw (ParseException)jjte000;
                          }
                          throw (Error)jjte000;
                        } finally {
                          if (jjtc000) {
                            jjtree.closeNodeScope(jjtn000, true);
                            jjtreeCloseNodeScope(jjtn000);
                          }
                        }
/*@egen*/
		}

		void with() :
		{/*@bgen(jjtree) with */
                        ASTwith jjtn000 = new ASTwith(JJTWITH);
                        boolean jjtc000 = true;
                        jjtree.openNodeScope(jjtn000);
                        jjtreeOpenNodeScope(jjtn000);
/*@egen*/
			Token t;
		}
		{/*@bgen(jjtree) with */
                        try {
/*@egen*/
			<WITH>
			t = <NAME>
			{ st.addSymbol(t.image, "variable", ""); }
			// { st.checkDeclaration(t.image, "variable", 0, "line " + t.beginLine + ", column " + t.beginColumn); }
			( <IN> | <EQUAL> ) 
			expression()
			statements()
			<END> ( <WITH> )?/*@bgen(jjtree)*/
                                        {
                                          jjtree.closeNodeScope(jjtn000, true);
                                          jjtc000 = false;
                                          jjtreeCloseNodeScope(jjtn000);
                                        }
/*@egen*/
					{ st.removeAuxVariable(t.image); }/*@bgen(jjtree)*/
                        } catch (Throwable jjte000) {
                          if (jjtc000) {
                            jjtree.clearNodeScope(jjtn000);
                            jjtc000 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte000 instanceof RuntimeException) {
                            throw (RuntimeException)jjte000;
                          }
                          if (jjte000 instanceof ParseException) {
                            throw (ParseException)jjte000;
                          }
                          throw (Error)jjte000;
                        } finally {
                          if (jjtc000) {
                            jjtree.closeNodeScope(jjtn000, true);
                            jjtreeCloseNodeScope(jjtn000);
                          }
                        }
/*@egen*/
		}

		void pAssert() :
		{/*@bgen(jjtree) pAssert */
  ASTpAssert jjtn000 = new ASTpAssert(JJTPASSERT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
		{/*@bgen(jjtree) pAssert */
                        try {
/*@egen*/
			<ASSERT>
			expression()/*@bgen(jjtree)*/
                        } catch (Throwable jjte000) {
                          if (jjtc000) {
                            jjtree.clearNodeScope(jjtn000);
                            jjtc000 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte000 instanceof RuntimeException) {
                            throw (RuntimeException)jjte000;
                          }
                          if (jjte000 instanceof ParseException) {
                            throw (ParseException)jjte000;
                          }
                          throw (Error)jjte000;
                        } finally {
                          if (jjtc000) {
                            jjtree.closeNodeScope(jjtn000, true);
                            jjtreeCloseNodeScope(jjtn000);
                          }
                        }
/*@egen*/
		}

		void print() :
		{/*@bgen(jjtree) print */
  ASTprint jjtn000 = new ASTprint(JJTPRINT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
		{/*@bgen(jjtree) print */
                        try {
/*@egen*/
			<PRINT>
			expression()/*@bgen(jjtree)*/
                        } catch (Throwable jjte000) {
                          if (jjtc000) {
                            jjtree.clearNodeScope(jjtn000);
                            jjtc000 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte000 instanceof RuntimeException) {
                            throw (RuntimeException)jjte000;
                          }
                          if (jjte000 instanceof ParseException) {
                            throw (ParseException)jjte000;
                          }
                          throw (Error)jjte000;
                        } finally {
                          if (jjtc000) {
                            jjtree.closeNodeScope(jjtn000, true);
                            jjtreeCloseNodeScope(jjtn000);
                          }
                        }
/*@egen*/
		}

		void procedureCall() :
		{/*@bgen(jjtree) procedureCall */
                        ASTprocedureCall jjtn000 = new ASTprocedureCall(JJTPROCEDURECALL);
                        boolean jjtc000 = true;
                        jjtree.openNodeScope(jjtn000);
                        jjtreeOpenNodeScope(jjtn000);
/*@egen*/
			Token t;
			int noofparameters;
		}
		{/*@bgen(jjtree) procedureCall */
                        try {
/*@egen*/
			t = <NAME>
			noofparameters = paramInstances()/*@bgen(jjtree)*/
                        {
                          jjtree.closeNodeScope(jjtn000, true);
                          jjtc000 = false;
                          jjtreeCloseNodeScope(jjtn000);
                        }
/*@egen*/
			{ st.checkDeclaration(t.image, "function", noofparameters, "line " + t.beginLine + ", column " + t.beginColumn); }/*@bgen(jjtree)*/
                        } catch (Throwable jjte000) {
                          if (jjtc000) {
                            jjtree.clearNodeScope(jjtn000);
                            jjtc000 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte000 instanceof RuntimeException) {
                            throw (RuntimeException)jjte000;
                          }
                          if (jjte000 instanceof ParseException) {
                            throw (ParseException)jjte000;
                          }
                          throw (Error)jjte000;
                        } finally {
                          if (jjtc000) {
                            jjtree.closeNodeScope(jjtn000, true);
                            jjtreeCloseNodeScope(jjtn000);
                          }
                        }
/*@egen*/
		}

		void definitionCall() :
		{/*@bgen(jjtree) definitionCall */
                        ASTdefinitionCall jjtn000 = new ASTdefinitionCall(JJTDEFINITIONCALL);
                        boolean jjtc000 = true;
                        jjtree.openNodeScope(jjtn000);
                        jjtreeOpenNodeScope(jjtn000);
/*@egen*/
			Token t;
			int noofparameters;
		}
		{/*@bgen(jjtree) definitionCall */
                        try {
/*@egen*/
			t = <NAME>
			noofparameters = paramInstances()/*@bgen(jjtree)*/
                        {
                          jjtree.closeNodeScope(jjtn000, true);
                          jjtc000 = false;
                          jjtreeCloseNodeScope(jjtn000);
                        }
/*@egen*/
			{ st.checkDeclaration(t.image, "definition", noofparameters, "line " + t.beginLine + ", column " + t.beginColumn); }/*@bgen(jjtree)*/
                        } catch (Throwable jjte000) {
                          if (jjtc000) {
                            jjtree.clearNodeScope(jjtn000);
                            jjtc000 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte000 instanceof RuntimeException) {
                            throw (RuntimeException)jjte000;
                          }
                          if (jjte000 instanceof ParseException) {
                            throw (ParseException)jjte000;
                          }
                          throw (Error)jjte000;
                        } finally {
                          if (jjtc000) {
                            jjtree.closeNodeScope(jjtn000, true);
                            jjtreeCloseNodeScope(jjtn000);
                          }
                        }
/*@egen*/
		}

		void pReturn() :
		{/*@bgen(jjtree) pReturn */
  ASTpReturn jjtn000 = new ASTpReturn(JJTPRETURN);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
		{/*@bgen(jjtree) pReturn */
                        try {
/*@egen*/
			<RETURN>
			(
					expression()
			)?/*@bgen(jjtree)*/
                        } catch (Throwable jjte000) {
                          if (jjtc000) {
                            jjtree.clearNodeScope(jjtn000);
                            jjtc000 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte000 instanceof RuntimeException) {
                            throw (RuntimeException)jjte000;
                          }
                          if (jjte000 instanceof ParseException) {
                            throw (ParseException)jjte000;
                          }
                          throw (Error)jjte000;
                        } finally {
                          if (jjtc000) {
                            jjtree.closeNodeScope(jjtn000, true);
                            jjtreeCloseNodeScope(jjtn000);
                          }
                        }
/*@egen*/
		}

		void pGoto() :
		{/*@bgen(jjtree) pGoto */
  ASTpGoto jjtn000 = new ASTpGoto(JJTPGOTO);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
		{/*@bgen(jjtree) pGoto */
                        try {
/*@egen*/
			<GOTO>
			<NAME>/*@bgen(jjtree)*/
                        } finally {
                          if (jjtc000) {
                            jjtree.closeNodeScope(jjtn000, true);
                            jjtreeCloseNodeScope(jjtn000);
                          }
                        }
/*@egen*/
		}

		void pBreak() :
		{/*@bgen(jjtree) pBreak */
  ASTpBreak jjtn000 = new ASTpBreak(JJTPBREAK);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
		{/*@bgen(jjtree) pBreak */
                        try {
/*@egen*/
			<BREAK>/*@bgen(jjtree)*/
                        } finally {
                          if (jjtc000) {
                            jjtree.closeNodeScope(jjtn000, true);
                            jjtreeCloseNodeScope(jjtn000);
                          }
                        }
/*@egen*/
		}

		void run() :
		{/*@bgen(jjtree) run */
                        ASTrun jjtn000 = new ASTrun(JJTRUN);
                        boolean jjtc000 = true;
                        jjtree.openNodeScope(jjtn000);
                        jjtreeOpenNodeScope(jjtn000);
/*@egen*/ 
			Token t; 
			int noofparameters = 0;
		}
		{/*@bgen(jjtree) run */
                        try {
/*@egen*/
			<RUN>
			( // optionally specify whether to run process or thread
					<PROCESS>
					|
					<THREAD>
			)?
					{jjtreeOpenNodeScope(jjtn000);}
			t = <NAME>
			( noofparameters = paramInstances() )?/*@bgen(jjtree)*/
                                        {
                                          jjtree.closeNodeScope(jjtn000, true);
                                          jjtc000 = false;
                                          jjtreeCloseNodeScope(jjtn000);
                                        }
/*@egen*/
					{ st.checkDeclaration(t.image, "process", noofparameters, "line " + t.beginLine + ", column " + t.beginColumn); }/*@bgen(jjtree)*/
                        } catch (Throwable jjte000) {
                          if (jjtc000) {
                            jjtree.clearNodeScope(jjtn000);
                            jjtc000 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte000 instanceof RuntimeException) {
                            throw (RuntimeException)jjte000;
                          }
                          if (jjte000 instanceof ParseException) {
                            throw (ParseException)jjte000;
                          }
                          throw (Error)jjte000;
                        } finally {
                          if (jjtc000) {
                            jjtree.closeNodeScope(jjtn000, true);
                            jjtreeCloseNodeScope(jjtn000);
                          }
                        }
/*@egen*/
		}

		// ------------------------ symmetry, fairness, property -------------------

		void symmetry() :
		{/*@bgen(jjtree) symmetry */
  ASTsymmetry jjtn000 = new ASTsymmetry(JJTSYMMETRY);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
		{/*@bgen(jjtree) symmetry */
                        try {
/*@egen*/
			( <SYMMETRY> )?/*@bgen(jjtree)*/
                        } finally {
                          if (jjtc000) {
                            jjtree.closeNodeScope(jjtn000, true);
                            jjtreeCloseNodeScope(jjtn000);
                          }
                        }
/*@egen*/
		}

		void fairness() :
		{/*@bgen(jjtree) fairness */
  ASTfairness jjtn000 = new ASTfairness(JJTFAIRNESS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
		{/*@bgen(jjtree) fairness */
                        try {
/*@egen*/
			(
					( <STRONG> )?
							<FAIR>
			)?/*@bgen(jjtree)*/
                        } finally {
                          if (jjtc000) {
                            jjtree.closeNodeScope(jjtn000, true);
                            jjtreeCloseNodeScope(jjtn000);
                          }
                        }
/*@egen*/
		}

		void property() :
		{/*@bgen(jjtree) property */
  ASTproperty jjtn000 = new ASTproperty(JJTPROPERTY);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
		{/*@bgen(jjtree) property */
                        try {
/*@egen*/
			invariant()
			|
			temporal()/*@bgen(jjtree)*/
                        } catch (Throwable jjte000) {
                          if (jjtc000) {
                            jjtree.clearNodeScope(jjtn000);
                            jjtc000 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte000 instanceof RuntimeException) {
                            throw (RuntimeException)jjte000;
                          }
                          if (jjte000 instanceof ParseException) {
                            throw (ParseException)jjte000;
                          }
                          throw (Error)jjte000;
                        } finally {
                          if (jjtc000) {
                            jjtree.closeNodeScope(jjtn000, true);
                            jjtreeCloseNodeScope(jjtn000);
                          }
                        }
/*@egen*/
		}

		void invariant() :
		{/*@bgen(jjtree) invariant */
  ASTinvariant jjtn000 = new ASTinvariant(JJTINVARIANT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
		{/*@bgen(jjtree) invariant */
                        try {
/*@egen*/
			<INVARIANT>
			expression()/*@bgen(jjtree)*/
                        } catch (Throwable jjte000) {
                          if (jjtc000) {
                            jjtree.clearNodeScope(jjtn000);
                            jjtc000 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte000 instanceof RuntimeException) {
                            throw (RuntimeException)jjte000;
                          }
                          if (jjte000 instanceof ParseException) {
                            throw (ParseException)jjte000;
                          }
                          throw (Error)jjte000;
                        } finally {
                          if (jjtc000) {
                            jjtree.closeNodeScope(jjtn000, true);
                            jjtreeCloseNodeScope(jjtn000);
                          }
                        }
/*@egen*/
		}

		void temporal() :
		{/*@bgen(jjtree) temporal */
  ASTtemporal jjtn000 = new ASTtemporal(JJTTEMPORAL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
		{/*@bgen(jjtree) temporal */
                        try {
/*@egen*/
			<TEMPORAL>
			expression()/*@bgen(jjtree)*/
                        } catch (Throwable jjte000) {
                          if (jjtc000) {
                            jjtree.clearNodeScope(jjtn000);
                            jjtc000 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte000 instanceof RuntimeException) {
                            throw (RuntimeException)jjte000;
                          }
                          if (jjte000 instanceof ParseException) {
                            throw (ParseException)jjte000;
                          }
                          throw (Error)jjte000;
                        } finally {
                          if (jjtc000) {
                            jjtree.closeNodeScope(jjtn000, true);
                            jjtreeCloseNodeScope(jjtn000);
                          }
                        }
/*@egen*/   //  tFormula()
		}

		void bounds() :
		{/*@bgen(jjtree) bounds */
  ASTbounds jjtn000 = new ASTbounds(JJTBOUNDS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
		{/*@bgen(jjtree) bounds */
                        try {
/*@egen*/
			bound()
			(
					<COMMA>
					bound()
			)*/*@bgen(jjtree)*/
                        } catch (Throwable jjte000) {
                          if (jjtc000) {
                            jjtree.clearNodeScope(jjtn000);
                            jjtc000 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte000 instanceof RuntimeException) {
                            throw (RuntimeException)jjte000;
                          }
                          if (jjte000 instanceof ParseException) {
                            throw (ParseException)jjte000;
                          }
                          throw (Error)jjte000;
                        } finally {
                          if (jjtc000) {
                            jjtree.closeNodeScope(jjtn000, true);
                            jjtreeCloseNodeScope(jjtn000);
                          }
                        }
/*@egen*/
		}

		void bound() :
		{/*@bgen(jjtree) bound */
  ASTbound jjtn000 = new ASTbound(JJTBOUND);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
		{/*@bgen(jjtree) bound */
                        try {
/*@egen*/
			<NAME> ( <COMMA> <NAME> )*
			<IN>
			expression()/*@bgen(jjtree)*/
                        } catch (Throwable jjte000) {
                          if (jjtc000) {
                            jjtree.clearNodeScope(jjtn000);
                            jjtc000 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte000 instanceof RuntimeException) {
                            throw (RuntimeException)jjte000;
                          }
                          if (jjte000 instanceof ParseException) {
                            throw (ParseException)jjte000;
                          }
                          throw (Error)jjte000;
                        } finally {
                          if (jjtc000) {
                            jjtree.closeNodeScope(jjtn000, true);
                            jjtreeCloseNodeScope(jjtn000);
                          }
                        }
/*@egen*/
		}

		/*****
  The following was a valiant attempt to distinguish between
  temporal and non-temporal formulas. Seems too hard to be worthwhile.

  Priority levels for binary operators in temporal formulas:
  conjunction > disjunction > implication, equivalence

void tFormula() :
{}
{
  expression()
  (
    tQuantified()  
  |
    tImplicand()
    (
      ( <LIMP> | <LEQUIV> )
      tImplicand()
    )?
  )
}

void tQuantified() :
{}
{
  ( <FORALL> | <EXISTS> )
  bounds()     // unbounded quantification useless for model checking
  <COLON>
  tFormula()
}

void tImplicand() :
{}
{
  tDisjunct()
  (
    <LOR>
    tDisjunct()
  )*
}

void tDisjunct() :
{}
{
  tConjunct()
  (
    <LAND>
    tConjunct()
  )*
}

void tConjunct() :
{}
{
  (
    tUnary()
  |
    tAtomic()
  )
}

void tUnary() :
{}
{
  ( <LNOT> | <BOX> | <DIAMOND> )
  tConjunct()
}

void tAtomic() :
{}
{
  (
    expression()
  |
    <LPAR>
    tFormula()
    <RPAR>
  )
}

		 ****/

		// ------------------------------ instance syntax --------------------------

		void instance() :
		{/*@bgen(jjtree) instance */
  ASTinstance jjtn000 = new ASTinstance(JJTINSTANCE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
		{/*@bgen(jjtree) instance */
                        try {
/*@egen*/
			(
					config()
			)+/*@bgen(jjtree)*/
                        } catch (Throwable jjte000) {
                          if (jjtc000) {
                            jjtree.clearNodeScope(jjtn000);
                            jjtc000 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte000 instanceof RuntimeException) {
                            throw (RuntimeException)jjte000;
                          }
                          if (jjte000 instanceof ParseException) {
                            throw (ParseException)jjte000;
                          }
                          throw (Error)jjte000;
                        } finally {
                          if (jjtc000) {
                            jjtree.closeNodeScope(jjtn000, true);
                            jjtreeCloseNodeScope(jjtn000);
                          }
                        }
/*@egen*/
		}

		void config() :
		{/*@bgen(jjtree) config */
  ASTconfig jjtn000 = new ASTconfig(JJTCONFIG);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
		{/*@bgen(jjtree) config */
                        try {
/*@egen*/
			constantDefs()
			|
			constraint()/*@bgen(jjtree)*/
                        } catch (Throwable jjte000) {
                          if (jjtc000) {
                            jjtree.clearNodeScope(jjtn000);
                            jjtc000 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte000 instanceof RuntimeException) {
                            throw (RuntimeException)jjte000;
                          }
                          if (jjte000 instanceof ParseException) {
                            throw (ParseException)jjte000;
                          }
                          throw (Error)jjte000;
                        } finally {
                          if (jjtc000) {
                            jjtree.closeNodeScope(jjtn000, true);
                            jjtreeCloseNodeScope(jjtn000);
                          }
                        }
/*@egen*/  
		}

		void constantDefs() :
		{/*@bgen(jjtree) constantDefs */
  ASTconstantDefs jjtn000 = new ASTconstantDefs(JJTCONSTANTDEFS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
		{/*@bgen(jjtree) constantDefs */
                        try {
/*@egen*/
			<CONSTANT>
			constantDef()
			(
					<COMMA>
					constantDef()
			)*/*@bgen(jjtree)*/
                        } catch (Throwable jjte000) {
                          if (jjtc000) {
                            jjtree.clearNodeScope(jjtn000);
                            jjtc000 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte000 instanceof RuntimeException) {
                            throw (RuntimeException)jjte000;
                          }
                          if (jjte000 instanceof ParseException) {
                            throw (ParseException)jjte000;
                          }
                          throw (Error)jjte000;
                        } finally {
                          if (jjtc000) {
                            jjtree.closeNodeScope(jjtn000, true);
                            jjtreeCloseNodeScope(jjtn000);
                          }
                        }
/*@egen*/
		}

		void constantDef() :
		{/*@bgen(jjtree) constantDef */
                  ASTconstantDef jjtn000 = new ASTconstantDef(JJTCONSTANTDEF);
                  boolean jjtc000 = true;
                  jjtree.openNodeScope(jjtn000);
                  jjtreeOpenNodeScope(jjtn000);
/*@egen*/ Token t = null; }
		{/*@bgen(jjtree) constantDef */
                        try {
/*@egen*/
			t = <NAME> {st.updateConstantInitialization(t.image);}
			<EQUAL>
			expression()/*@bgen(jjtree)*/
                        } catch (Throwable jjte000) {
                          if (jjtc000) {
                            jjtree.clearNodeScope(jjtn000);
                            jjtc000 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte000 instanceof RuntimeException) {
                            throw (RuntimeException)jjte000;
                          }
                          if (jjte000 instanceof ParseException) {
                            throw (ParseException)jjte000;
                          }
                          throw (Error)jjte000;
                        } finally {
                          if (jjtc000) {
                            jjtree.closeNodeScope(jjtn000, true);
                            jjtreeCloseNodeScope(jjtn000);
                          }
                        }
/*@egen*/    // constant expression
		}

		void constraint() :
		{/*@bgen(jjtree) constraint */
  ASTconstraint jjtn000 = new ASTconstraint(JJTCONSTRAINT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
		{/*@bgen(jjtree) constraint */
                        try {
/*@egen*/
			<CONSTRAINT>
			expression()/*@bgen(jjtree)*/
                        } catch (Throwable jjte000) {
                          if (jjtc000) {
                            jjtree.clearNodeScope(jjtn000);
                            jjtc000 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte000 instanceof RuntimeException) {
                            throw (RuntimeException)jjte000;
                          }
                          if (jjte000 instanceof ParseException) {
                            throw (ParseException)jjte000;
                          }
                          throw (Error)jjte000;
                        } finally {
                          if (jjtc000) {
                            jjtree.closeNodeScope(jjtn000, true);
                            jjtreeCloseNodeScope(jjtn000);
                          }
                        }
/*@egen*/
		}

		// ------------------------------ expression syntax ------------------------

		void expression() :
		{/*@bgen(jjtree) expression */
  ASTexpression jjtn000 = new ASTexpression(JJTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
		{/*@bgen(jjtree) expression */
                        try {
/*@egen*/
			(
					quantExpression()
					|
					condExpression()
					|
					caseExpression()
					|
					letExpression()
					|
					exp1()
			)/*@bgen(jjtree)*/
                        } catch (Throwable jjte000) {
                          if (jjtc000) {
                            jjtree.clearNodeScope(jjtn000);
                            jjtc000 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte000 instanceof RuntimeException) {
                            throw (RuntimeException)jjte000;
                          }
                          if (jjte000 instanceof ParseException) {
                            throw (ParseException)jjte000;
                          }
                          throw (Error)jjte000;
                        } finally {
                          if (jjtc000) {
                            jjtree.closeNodeScope(jjtn000, true);
                            jjtreeCloseNodeScope(jjtn000);
                          }
                        }
/*@egen*/
		}

		// --------------------- improperly bracketed expressions ------------------
		// Quantified expressions as well as LET, CASE, and IF constructs are not
		// properly bracketed. They must be parenthesized when they appear as
		// subexpressions for disambiguation and are therefore handled separately
		// from standard expressions (see production exp1() below).

		void quantExpression() :  // only bounded quantification allowed here
		{/*@bgen(jjtree) quantExpression */
  ASTquantExpression jjtn000 = new ASTquantExpression(JJTQUANTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
		{/*@bgen(jjtree) quantExpression */
                        try {
/*@egen*/
			( <FORALL> | <EXISTS> | <CHOOSE> )
			bounds()
			<COLON>
			expression()/*@bgen(jjtree)*/
                        } catch (Throwable jjte000) {
                          if (jjtc000) {
                            jjtree.clearNodeScope(jjtn000);
                            jjtc000 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte000 instanceof RuntimeException) {
                            throw (RuntimeException)jjte000;
                          }
                          if (jjte000 instanceof ParseException) {
                            throw (ParseException)jjte000;
                          }
                          throw (Error)jjte000;
                        } finally {
                          if (jjtc000) {
                            jjtree.closeNodeScope(jjtn000, true);
                            jjtreeCloseNodeScope(jjtn000);
                          }
                        }
/*@egen*/
		}

		void condExpression() :
		{/*@bgen(jjtree) condExpression */
  ASTcondExpression jjtn000 = new ASTcondExpression(JJTCONDEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
		{/*@bgen(jjtree) condExpression */
                        try {
/*@egen*/
			<EIF>
			expression()
			<ETHEN>
			expression()
			<EELSE>
			expression()/*@bgen(jjtree)*/
                        } catch (Throwable jjte000) {
                          if (jjtc000) {
                            jjtree.clearNodeScope(jjtn000);
                            jjtc000 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte000 instanceof RuntimeException) {
                            throw (RuntimeException)jjte000;
                          }
                          if (jjte000 instanceof ParseException) {
                            throw (ParseException)jjte000;
                          }
                          throw (Error)jjte000;
                        } finally {
                          if (jjtc000) {
                            jjtree.closeNodeScope(jjtn000, true);
                            jjtreeCloseNodeScope(jjtn000);
                          }
                        }
/*@egen*/
		}

		void caseExpression() :
			/* CASE in TLA+ has the "dangling else" problem because the
   OTHER clause is optional. The LOOKAHEAD specifications
   below suppress a warning to that effect, and the
   interpretation of the expression
     CASE P -> CASE Q -> 0 [] R -> 1 OTHER  -> 2
   associates the second arm and the OTHER clause to the 
   inner case expression:
     CASE P ->
       CASE Q -> 0
       []   R -> 1
       OTHER  -> 2
   which is presumably what the author intended.
			 */
		{/*@bgen(jjtree) caseExpression */
  ASTcaseExpression jjtn000 = new ASTcaseExpression(JJTCASEEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
		{/*@bgen(jjtree) caseExpression */
                        try {
/*@egen*/
			<ECASE>
			caseArm()
			( 
					LOOKAHEAD(1)
					<BOX> caseArm()
			)*
			( LOOKAHEAD(1)
					<EOTHER> <ARROW> expression()
			)?/*@bgen(jjtree)*/
                        } catch (Throwable jjte000) {
                          if (jjtc000) {
                            jjtree.clearNodeScope(jjtn000);
                            jjtc000 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte000 instanceof RuntimeException) {
                            throw (RuntimeException)jjte000;
                          }
                          if (jjte000 instanceof ParseException) {
                            throw (ParseException)jjte000;
                          }
                          throw (Error)jjte000;
                        } finally {
                          if (jjtc000) {
                            jjtree.closeNodeScope(jjtn000, true);
                            jjtreeCloseNodeScope(jjtn000);
                          }
                        }
/*@egen*/
		}

		void caseArm() :
		{/*@bgen(jjtree) caseArm */
  ASTcaseArm jjtn000 = new ASTcaseArm(JJTCASEARM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
		{/*@bgen(jjtree) caseArm */
                        try {
/*@egen*/
			expression()
			<ARROW>
			expression()/*@bgen(jjtree)*/
                        } catch (Throwable jjte000) {
                          if (jjtc000) {
                            jjtree.clearNodeScope(jjtn000);
                            jjtc000 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte000 instanceof RuntimeException) {
                            throw (RuntimeException)jjte000;
                          }
                          if (jjte000 instanceof ParseException) {
                            throw (ParseException)jjte000;
                          }
                          throw (Error)jjte000;
                        } finally {
                          if (jjtc000) {
                            jjtree.closeNodeScope(jjtn000, true);
                            jjtreeCloseNodeScope(jjtn000);
                          }
                        }
/*@egen*/
		}

		void letExpression() :
		{/*@bgen(jjtree) letExpression */
  ASTletExpression jjtn000 = new ASTletExpression(JJTLETEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
		{/*@bgen(jjtree) letExpression */
                        try {
/*@egen*/
			<LET>
			( LOOKAHEAD(2)
					functionDefinition()
					|
					operatorDefinition()
			)+
			<LETIN>
			expression()/*@bgen(jjtree)*/
                        } catch (Throwable jjte000) {
                          if (jjtc000) {
                            jjtree.clearNodeScope(jjtn000);
                            jjtc000 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte000 instanceof RuntimeException) {
                            throw (RuntimeException)jjte000;
                          }
                          if (jjte000 instanceof ParseException) {
                            throw (ParseException)jjte000;
                          }
                          throw (Error)jjte000;
                        } finally {
                          if (jjtc000) {
                            jjtree.closeNodeScope(jjtn000, true);
                            jjtreeCloseNodeScope(jjtn000);
                          }
                        }
/*@egen*/
		}

		void operatorDefinition() :
		{/*@bgen(jjtree) operatorDefinition */
  ASToperatorDefinition jjtn000 = new ASToperatorDefinition(JJTOPERATORDEFINITION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
		{/*@bgen(jjtree) operatorDefinition */
                        try {
/*@egen*/
			(
					PREFIX() <NAME>
					|
					LOOKAHEAD(2)
					<NAME> <INFIX> <NAME>
					|
					LOOKAHEAD(2)
					<NAME> <POSTFIX>
					|
					nonfixLHS()   // Foo(a, Op(_,_), _ $$ _)
			)
			<DEQ>
			expression()/*@bgen(jjtree)*/
                        } catch (Throwable jjte000) {
                          if (jjtc000) {
                            jjtree.clearNodeScope(jjtn000);
                            jjtc000 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte000 instanceof RuntimeException) {
                            throw (RuntimeException)jjte000;
                          }
                          if (jjte000 instanceof ParseException) {
                            throw (ParseException)jjte000;
                          }
                          throw (Error)jjte000;
                        } finally {
                          if (jjtc000) {
                            jjtree.closeNodeScope(jjtn000, true);
                            jjtreeCloseNodeScope(jjtn000);
                          }
                        }
/*@egen*/
		}

		void nonfixLHS() :
		{/*@bgen(jjtree) nonfixLHS */
  ASTnonfixLHS jjtn000 = new ASTnonfixLHS(JJTNONFIXLHS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
		{/*@bgen(jjtree) nonfixLHS */
                        try {
/*@egen*/
			<NAME>
			(
					<LPAR>
					idOrOpdecl()
					(
							<COMMA> idOrOpdecl()
					)*
					<RPAR>
			)?/*@bgen(jjtree)*/
                        } catch (Throwable jjte000) {
                          if (jjtc000) {
                            jjtree.clearNodeScope(jjtn000);
                            jjtc000 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte000 instanceof RuntimeException) {
                            throw (RuntimeException)jjte000;
                          }
                          if (jjte000 instanceof ParseException) {
                            throw (ParseException)jjte000;
                          }
                          throw (Error)jjte000;
                        } finally {
                          if (jjtc000) {
                            jjtree.closeNodeScope(jjtn000, true);
                            jjtreeCloseNodeScope(jjtn000);
                          }
                        }
/*@egen*/
		}

		void idOrOpdecl() :
		{/*@bgen(jjtree) idOrOpdecl */
  ASTidOrOpdecl jjtn000 = new ASTidOrOpdecl(JJTIDOROPDECL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
		{/*@bgen(jjtree) idOrOpdecl */
                        try {
/*@egen*/
			(
					<NAME>
					(
							<LPAR>
							<UNDERSCORE>
							(
									<COMMA> <UNDERSCORE>
							)*
							<RPAR>
					)?
							|
							PREFIX() <UNDERSCORE>
					|
					LOOKAHEAD(2)
					<UNDERSCORE> <INFIX> <UNDERSCORE>
					|
					<UNDERSCORE> <POSTFIX>
			)/*@bgen(jjtree)*/
                        } catch (Throwable jjte000) {
                          if (jjtc000) {
                            jjtree.clearNodeScope(jjtn000);
                            jjtc000 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte000 instanceof RuntimeException) {
                            throw (RuntimeException)jjte000;
                          }
                          if (jjte000 instanceof ParseException) {
                            throw (ParseException)jjte000;
                          }
                          throw (Error)jjte000;
                        } finally {
                          if (jjtc000) {
                            jjtree.closeNodeScope(jjtn000, true);
                            jjtreeCloseNodeScope(jjtn000);
                          }
                        }
/*@egen*/
		}

		void functionDefinition() :
		{/*@bgen(jjtree) functionDefinition */
  ASTfunctionDefinition jjtn000 = new ASTfunctionDefinition(JJTFUNCTIONDEFINITION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
		{/*@bgen(jjtree) functionDefinition */
                        try {
/*@egen*/
			<NAME>
			<LBRAKK>
			bounds()
			<RBRAKK>
			<DEQ>
			expression()/*@bgen(jjtree)*/
                        } catch (Throwable jjte000) {
                          if (jjtc000) {
                            jjtree.clearNodeScope(jjtn000);
                            jjtc000 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte000 instanceof RuntimeException) {
                            throw (RuntimeException)jjte000;
                          }
                          if (jjte000 instanceof ParseException) {
                            throw (ParseException)jjte000;
                          }
                          throw (Error)jjte000;
                        } finally {
                          if (jjtc000) {
                            jjtree.closeNodeScope(jjtn000, true);
                            jjtreeCloseNodeScope(jjtn000);
                          }
                        }
/*@egen*/
		}

		//--------------------- (possibly) infix expressions --------------------------
		/*
  Infix expressions with operator priorities: see Chapter 15.2.1
  of the TLA+ book for an explanation.
		 */
		void exp1()       :
		{}
		{/*@bgen(jjtree) #infixOperator(> 1) */
                        {
                          ASTinfixOperator jjtn001 = new ASTinfixOperator(JJTINFIXOPERATOR);
                          boolean jjtc001 = true;
                          jjtree.openNodeScope(jjtn001);
                          jjtreeOpenNodeScope(jjtn001);
                        }
                        try {
/*@egen*/
			(
					exp2() {jjtreeOpenNodeScope(jjtn001);} ( ("=>") exp2() )? 
			)/*@bgen(jjtree)*/
                        } catch (Throwable jjte001) {
                          if (jjtc001) {
                            jjtree.clearNodeScope(jjtn001);
                            jjtc001 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte001 instanceof RuntimeException) {
                            throw (RuntimeException)jjte001;
                          }
                          if (jjte001 instanceof ParseException) {
                            throw (ParseException)jjte001;
                          }
                          throw (Error)jjte001;
                        } finally {
                          if (jjtc001) {
                            jjtree.closeNodeScope(jjtn001, jjtree.nodeArity() > 1);
                            jjtreeCloseNodeScope(jjtn001);
                          }
                        }
/*@egen*/                   
		}

		void exp2()       :
		{}
		{/*@bgen(jjtree) #infixOperator(> 1) */
                        {
                          ASTinfixOperator jjtn001 = new ASTinfixOperator(JJTINFIXOPERATOR);
                          boolean jjtc001 = true;
                          jjtree.openNodeScope(jjtn001);
                          jjtreeOpenNodeScope(jjtn001);
                        }
                        try {
/*@egen*/
			(
					exp3() {jjtreeOpenNodeScope(jjtn001);} ( ("~>" | "<=>" | "\\equiv" | "-+->") exp3() )?
			)/*@bgen(jjtree)*/
                        } catch (Throwable jjte001) {
                          if (jjtc001) {
                            jjtree.clearNodeScope(jjtn001);
                            jjtc001 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte001 instanceof RuntimeException) {
                            throw (RuntimeException)jjte001;
                          }
                          if (jjte001 instanceof ParseException) {
                            throw (ParseException)jjte001;
                          }
                          throw (Error)jjte001;
                        } finally {
                          if (jjtc001) {
                            jjtree.closeNodeScope(jjtn001, jjtree.nodeArity() > 1);
                            jjtreeCloseNodeScope(jjtn001);
                          }
                        }
/*@egen*/                   
		}

		void exp3()       :
		{}
		{/*@bgen(jjtree) #infixOperator(> 1) */
                        {
                          ASTinfixOperator jjtn001 = new ASTinfixOperator(JJTINFIXOPERATOR);
                          boolean jjtc001 = true;
                          jjtree.openNodeScope(jjtn001);
                          jjtreeOpenNodeScope(jjtn001);
                        }
                        try {
/*@egen*/
			(
					exp4_branch() {jjtreeOpenNodeScope(jjtn001);} ( ("\\/" | "/\\") exp4_branch() )*
			)/*@bgen(jjtree)*/
                        } catch (Throwable jjte001) {
                          if (jjtc001) {
                            jjtree.clearNodeScope(jjtn001);
                            jjtc001 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte001 instanceof RuntimeException) {
                            throw (RuntimeException)jjte001;
                          }
                          if (jjte001 instanceof ParseException) {
                            throw (ParseException)jjte001;
                          }
                          throw (Error)jjte001;
                        } finally {
                          if (jjtc001) {
                            jjtree.closeNodeScope(jjtn001, jjtree.nodeArity() > 1);
                            jjtreeCloseNodeScope(jjtn001);
                          }
                        }
/*@egen*/                   
		}

		void exp4_branch()       :
		{}
		{
			LOOKAHEAD(exp4to15noLeftAssoc())
			exp4to15noLeftAssoc()
			|
			exp4()
		}

		void exp4to15noLeftAssoc()        :
		{Token t = null;}
		{/*@bgen(jjtree) #prefixOperator( t != null) */
                        {
                          ASTprefixOperator jjtn001 = new ASTprefixOperator(JJTPREFIXOPERATOR);
                          boolean jjtc001 = true;
                          jjtree.openNodeScope(jjtn001);
                          jjtreeOpenNodeScope(jjtn001);
                        }
                        try {
/*@egen*/
			({jjtreeOpenNodeScope(jjtn001);} 
			(t = <BOX> | t = <DIAMOND>) exp17()
			)/*@bgen(jjtree)*/
                        } catch (Throwable jjte001) {
                          if (jjtc001) {
                            jjtree.clearNodeScope(jjtn001);
                            jjtc001 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte001 instanceof RuntimeException) {
                            throw (RuntimeException)jjte001;
                          }
                          if (jjte001 instanceof ParseException) {
                            throw (ParseException)jjte001;
                          }
                          throw (Error)jjte001;
                        } finally {
                          if (jjtc001) {
                            jjtree.closeNodeScope(jjtn001,  t != null);
                            jjtreeCloseNodeScope(jjtn001);
                          }
                        }
/*@egen*/                           
		}

		void exp4()       :
		{Token t = null;}
		{/*@bgen(jjtree) #prefixOperator( t != null) */
                        {
                          ASTprefixOperator jjtn001 = new ASTprefixOperator(JJTPREFIXOPERATOR);
                          boolean jjtc001 = true;
                          jjtree.openNodeScope(jjtn001);
                          jjtreeOpenNodeScope(jjtn001);
                        }
                        try {
/*@egen*/
			({jjtreeOpenNodeScope(jjtn001);} 
			(t = <LNOT>)? exp5()
			)/*@bgen(jjtree)*/
                        } catch (Throwable jjte001) {
                          if (jjtc001) {
                            jjtree.clearNodeScope(jjtn001);
                            jjtc001 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte001 instanceof RuntimeException) {
                            throw (RuntimeException)jjte001;
                          }
                          if (jjte001 instanceof ParseException) {
                            throw (ParseException)jjte001;
                          }
                          throw (Error)jjte001;
                        } finally {
                          if (jjtc001) {
                            jjtree.closeNodeScope(jjtn001,  t != null);
                            jjtreeCloseNodeScope(jjtn001);
                          }
                        }
/*@egen*/                           
		}

		void exp5()       :
		{}
		{
			LOOKAHEAD(exp5a())
			exp5a()
			|
			exp5b()
		}

		void exp5a()       :
		{}
		{/*@bgen(jjtree) #infixOperator(> 1) */
                        {
                          ASTinfixOperator jjtn001 = new ASTinfixOperator(JJTINFIXOPERATOR);
                          boolean jjtc001 = true;
                          jjtree.openNodeScope(jjtn001);
                          jjtreeOpenNodeScope(jjtn001);
                        }
                        try {
/*@egen*/
			(
					exp6() {jjtreeOpenNodeScope(jjtn001);} 
					("@" | "#" | "/=" | "-|" | "::=" | "<" | "=" | "=|" | ">" | "\\approx" | "\\asymp" | "\\cong" | "\\doteq" | "\\geq" | ">=" | "\\gg" | "\\in" | "\\notin" | "\\leq" | "=<" | "<=" | "\\ll" | "\\prec" | "\\preceq" | "\\propto" | "\\sim" | "\\simeq" | "\\sqsubset" | "\\sqsubseteq" | "\\sqsupset" | "\\sqsupseteq" | "\\subset" | "\\subseteq" | "\\succ" | "\\succeq" | "\\supset" | "\\supseteq" | "|-" | "|=")
					exp6()
			)/*@bgen(jjtree)*/
                        } catch (Throwable jjte001) {
                          if (jjtc001) {
                            jjtree.clearNodeScope(jjtn001);
                            jjtc001 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte001 instanceof RuntimeException) {
                            throw (RuntimeException)jjte001;
                          }
                          if (jjte001 instanceof ParseException) {
                            throw (ParseException)jjte001;
                          }
                          throw (Error)jjte001;
                        } finally {
                          if (jjtc001) {
                            jjtree.closeNodeScope(jjtn001, jjtree.nodeArity() > 1);
                            jjtreeCloseNodeScope(jjtn001);
                          }
                        }
/*@egen*/                   
		}

		void exp5b()       :
		{}
		{/*@bgen(jjtree) #infixOperator(> 1) */
                        {
                          ASTinfixOperator jjtn001 = new ASTinfixOperator(JJTINFIXOPERATOR);
                          boolean jjtc001 = true;
                          jjtree.openNodeScope(jjtn001);
                          jjtreeOpenNodeScope(jjtn001);
                        }
                        try {
/*@egen*/
			(
					exp6() {jjtreeOpenNodeScope(jjtn001);} ( ("\\cdot") exp6() )*
			)/*@bgen(jjtree)*/
                        } catch (Throwable jjte001) {
                          if (jjtc001) {
                            jjtree.clearNodeScope(jjtn001);
                            jjtc001 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte001 instanceof RuntimeException) {
                            throw (RuntimeException)jjte001;
                          }
                          if (jjte001 instanceof ParseException) {
                            throw (ParseException)jjte001;
                          }
                          throw (Error)jjte001;
                        } finally {
                          if (jjtc001) {
                            jjtree.closeNodeScope(jjtn001, jjtree.nodeArity() > 1);
                            jjtreeCloseNodeScope(jjtn001);
                          }
                        }
/*@egen*/                   
		}

		void exp6()       :
		{}
		{/*@bgen(jjtree) #infixOperator(> 1) */
                        {
                          ASTinfixOperator jjtn001 = new ASTinfixOperator(JJTINFIXOPERATOR);
                          boolean jjtc001 = true;
                          jjtree.openNodeScope(jjtn001);
                          jjtreeOpenNodeScope(jjtn001);
                        }
                        try {
/*@egen*/
			(
					exp7() {jjtreeOpenNodeScope(jjtn001);} ( ("@@") exp7() )*
			)/*@bgen(jjtree)*/
                        } catch (Throwable jjte001) {
                          if (jjtc001) {
                            jjtree.clearNodeScope(jjtn001);
                            jjtc001 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte001 instanceof RuntimeException) {
                            throw (RuntimeException)jjte001;
                          }
                          if (jjte001 instanceof ParseException) {
                            throw (ParseException)jjte001;
                          }
                          throw (Error)jjte001;
                        } finally {
                          if (jjtc001) {
                            jjtree.closeNodeScope(jjtn001, jjtree.nodeArity() > 1);
                            jjtreeCloseNodeScope(jjtn001);
                          }
                        }
/*@egen*/                   
		}

		void exp7()       :
		{}
		{/*@bgen(jjtree) #infixOperator(> 1) */
                        {
                          ASTinfixOperator jjtn001 = new ASTinfixOperator(JJTINFIXOPERATOR);
                          boolean jjtc001 = true;
                          jjtree.openNodeScope(jjtn001);
                          jjtreeOpenNodeScope(jjtn001);
                        }
                        try {
/*@egen*/
			(
					exp8() {jjtreeOpenNodeScope(jjtn001);} ( (":>" | "<:") exp8() )?
			)/*@bgen(jjtree)*/
                        } catch (Throwable jjte001) {
                          if (jjtc001) {
                            jjtree.clearNodeScope(jjtn001);
                            jjtc001 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte001 instanceof RuntimeException) {
                            throw (RuntimeException)jjte001;
                          }
                          if (jjte001 instanceof ParseException) {
                            throw (ParseException)jjte001;
                          }
                          throw (Error)jjte001;
                        } finally {
                          if (jjtc001) {
                            jjtree.closeNodeScope(jjtn001, jjtree.nodeArity() > 1);
                            jjtreeCloseNodeScope(jjtn001);
                          }
                        }
/*@egen*/                   
		}

		void exp8()       :
		{}
		{
			LOOKAHEAD(exp8noLeftAssoc())
			exp8noLeftAssoc()
			|
			exp8LeftAssoc()
		}

		void exp8noLeftAssoc()       :
		{}
		{/*@bgen(jjtree) #infixOperator(> 1) */
                        {
                          ASTinfixOperator jjtn001 = new ASTinfixOperator(JJTINFIXOPERATOR);
                          boolean jjtc001 = true;
                          jjtree.openNodeScope(jjtn001);
                          jjtreeOpenNodeScope(jjtn001);
                        }
                        try {
/*@egen*/
			(
					exp9() {jjtreeOpenNodeScope(jjtn001);} ("\\") exp9()
			)/*@bgen(jjtree)*/
                        } catch (Throwable jjte001) {
                          if (jjtc001) {
                            jjtree.clearNodeScope(jjtn001);
                            jjtc001 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte001 instanceof RuntimeException) {
                            throw (RuntimeException)jjte001;
                          }
                          if (jjte001 instanceof ParseException) {
                            throw (ParseException)jjte001;
                          }
                          throw (Error)jjte001;
                        } finally {
                          if (jjtc001) {
                            jjtree.closeNodeScope(jjtn001, jjtree.nodeArity() > 1);
                            jjtreeCloseNodeScope(jjtn001);
                          }
                        }
/*@egen*/                   
		}

		void exp8LeftAssoc()       :
		{}
		{/*@bgen(jjtree) #infixOperator(> 1) */
                        {
                          ASTinfixOperator jjtn001 = new ASTinfixOperator(JJTINFIXOPERATOR);
                          boolean jjtc001 = true;
                          jjtree.openNodeScope(jjtn001);
                          jjtreeOpenNodeScope(jjtn001);
                        }
                        try {
/*@egen*/
			(
					exp9() {jjtreeOpenNodeScope(jjtn001);} ( ("\\cap" | "\\intersect" | "\\cup" | "\\union") exp9() )*
			)/*@bgen(jjtree)*/
                        } catch (Throwable jjte001) {
                          if (jjtc001) {
                            jjtree.clearNodeScope(jjtn001);
                            jjtc001 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte001 instanceof RuntimeException) {
                            throw (RuntimeException)jjte001;
                          }
                          if (jjte001 instanceof ParseException) {
                            throw (ParseException)jjte001;
                          }
                          throw (Error)jjte001;
                        } finally {
                          if (jjtc001) {
                            jjtree.closeNodeScope(jjtn001, jjtree.nodeArity() > 1);
                            jjtreeCloseNodeScope(jjtn001);
                          }
                        }
/*@egen*/                   
		}

		void exp9()       :
		{}
		{
			LOOKAHEAD(exp9notLeftAssoc())
			exp9notLeftAssoc()
			|
			exp9to14_level_1()
		}

		void exp9notLeftAssoc()       :
		{}
		{/*@bgen(jjtree) #infixOperator(> 1) */
                        {
                          ASTinfixOperator jjtn001 = new ASTinfixOperator(JJTINFIXOPERATOR);
                          boolean jjtc001 = true;
                          jjtree.openNodeScope(jjtn001);
                          jjtreeOpenNodeScope(jjtn001);
                        }
                        try {
/*@egen*/
			(
					exp9notLeftAssoc_branch() {jjtreeOpenNodeScope(jjtn001);} (".." | "...") exp9notLeftAssoc_branch()
			)/*@bgen(jjtree)*/
                        } catch (Throwable jjte001) {
                          if (jjtc001) {
                            jjtree.clearNodeScope(jjtn001);
                            jjtc001 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte001 instanceof RuntimeException) {
                            throw (RuntimeException)jjte001;
                          }
                          if (jjte001 instanceof ParseException) {
                            throw (ParseException)jjte001;
                          }
                          throw (Error)jjte001;
                        } finally {
                          if (jjtc001) {
                            jjtree.closeNodeScope(jjtn001, jjtree.nodeArity() > 1);
                            jjtreeCloseNodeScope(jjtn001);
                          }
                        }
/*@egen*/                   
		}

		void exp9notLeftAssoc_branch()       :
		{}
		{
			LOOKAHEAD(exp10to11notLeftAssoc())
			exp10to11notLeftAssoc()
			|
			exp10LeftAssoc_1()
		}

		void exp10to11notLeftAssoc()       :
		{}
		{/*@bgen(jjtree) #infixOperator(> 1) */
                        {
                          ASTinfixOperator jjtn001 = new ASTinfixOperator(JJTINFIXOPERATOR);
                          boolean jjtc001 = true;
                          jjtree.openNodeScope(jjtn001);
                          jjtreeOpenNodeScope(jjtn001);
                        }
                        try {
/*@egen*/
			(
					exp12_1() {jjtreeOpenNodeScope(jjtn001);} ("%") exp12_1()
			)/*@bgen(jjtree)*/
                        } catch (Throwable jjte001) {
                          if (jjtc001) {
                            jjtree.clearNodeScope(jjtn001);
                            jjtc001 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte001 instanceof RuntimeException) {
                            throw (RuntimeException)jjte001;
                          }
                          if (jjte001 instanceof ParseException) {
                            throw (ParseException)jjte001;
                          }
                          throw (Error)jjte001;
                        } finally {
                          if (jjtc001) {
                            jjtree.closeNodeScope(jjtn001, jjtree.nodeArity() > 1);
                            jjtreeCloseNodeScope(jjtn001);
                          }
                        }
/*@egen*/                   
		}

		void exp10LeftAssoc_1()       :
		{}
		{/*@bgen(jjtree) #infixOperator(> 1) */
                        {
                          ASTinfixOperator jjtn001 = new ASTinfixOperator(JJTINFIXOPERATOR);
                          boolean jjtc001 = true;
                          jjtree.openNodeScope(jjtn001);
                          jjtreeOpenNodeScope(jjtn001);
                        }
                        try {
/*@egen*/
			(
					exp10to11LeftAssoc_1() {jjtreeOpenNodeScope(jjtn001);} ( ("++" | "+" | "(+)" | "\\oplus") exp10to11LeftAssoc_1() )*
			)/*@bgen(jjtree)*/
                        } catch (Throwable jjte001) {
                          if (jjtc001) {
                            jjtree.clearNodeScope(jjtn001);
                            jjtc001 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte001 instanceof RuntimeException) {
                            throw (RuntimeException)jjte001;
                          }
                          if (jjte001 instanceof ParseException) {
                            throw (ParseException)jjte001;
                          }
                          throw (Error)jjte001;
                        } finally {
                          if (jjtc001) {
                            jjtree.closeNodeScope(jjtn001, jjtree.nodeArity() > 1);
                            jjtreeCloseNodeScope(jjtn001);
                          }
                        }
/*@egen*/                   
		}

		void exp10to11LeftAssoc_1()       :
		{}
		{/*@bgen(jjtree) #infixOperator(> 1) */
                        {
                          ASTinfixOperator jjtn001 = new ASTinfixOperator(JJTINFIXOPERATOR);
                          boolean jjtc001 = true;
                          jjtree.openNodeScope(jjtn001);
                          jjtreeOpenNodeScope(jjtn001);
                        }
                        try {
/*@egen*/
			(
					exp11LeftAssoc_1() {jjtreeOpenNodeScope(jjtn001);} ( LOOKAHEAD(2) ("%%" | "|" ) exp11LeftAssoc_1() )*
			)/*@bgen(jjtree)*/
                        } catch (Throwable jjte001) {
                          if (jjtc001) {
                            jjtree.clearNodeScope(jjtn001);
                            jjtc001 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte001 instanceof RuntimeException) {
                            throw (RuntimeException)jjte001;
                          }
                          if (jjte001 instanceof ParseException) {
                            throw (ParseException)jjte001;
                          }
                          throw (Error)jjte001;
                        } finally {
                          if (jjtc001) {
                            jjtree.closeNodeScope(jjtn001, jjtree.nodeArity() > 1);
                            jjtreeCloseNodeScope(jjtn001);
                          }
                        }
/*@egen*/                   
		}

		void exp11LeftAssoc_1()       :
		{}
		{/*@bgen(jjtree) #infixOperator(> 1) */
                        {
                          ASTinfixOperator jjtn001 = new ASTinfixOperator(JJTINFIXOPERATOR);
                          boolean jjtc001 = true;
                          jjtree.openNodeScope(jjtn001);
                          jjtreeOpenNodeScope(jjtn001);
                        }
                        try {
/*@egen*/
			(
					exp12_1() {jjtreeOpenNodeScope(jjtn001);} ( LOOKAHEAD(2) ("-" | "--" | "(-)") exp12_1() )*
			)/*@bgen(jjtree)*/
                        } catch (Throwable jjte001) {
                          if (jjtc001) {
                            jjtree.clearNodeScope(jjtn001);
                            jjtc001 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte001 instanceof RuntimeException) {
                            throw (RuntimeException)jjte001;
                          }
                          if (jjte001 instanceof ParseException) {
                            throw (ParseException)jjte001;
                          }
                          throw (Error)jjte001;
                        } finally {
                          if (jjtc001) {
                            jjtree.closeNodeScope(jjtn001, jjtree.nodeArity() > 1);
                            jjtreeCloseNodeScope(jjtn001);
                          }
                        }
/*@egen*/                   
		}

		void exp12_1()       :
		{ Token t = null;}
		{/*@bgen(jjtree) #prefixOperator( t != null) */
                        {
                          ASTprefixOperator jjtn001 = new ASTprefixOperator(JJTPREFIXOPERATOR);
                          boolean jjtc001 = true;
                          jjtree.openNodeScope(jjtn001);
                          jjtreeOpenNodeScope(jjtn001);
                        }
                        try {
/*@egen*/
			({jjtreeOpenNodeScope(jjtn001);} 
			(LOOKAHEAD(2) t = <MINUS>)? exp13_branch()
			)/*@bgen(jjtree)*/
                        } catch (Throwable jjte001) {
                          if (jjtc001) {
                            jjtree.clearNodeScope(jjtn001);
                            jjtc001 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte001 instanceof RuntimeException) {
                            throw (RuntimeException)jjte001;
                          }
                          if (jjte001 instanceof ParseException) {
                            throw (ParseException)jjte001;
                          }
                          throw (Error)jjte001;
                        } finally {
                          if (jjtc001) {
                            jjtree.closeNodeScope(jjtn001,  t != null);
                            jjtreeCloseNodeScope(jjtn001);
                          }
                        }
/*@egen*/                           
		}

		void exp13_branch()       : 
		{}
		{
			LOOKAHEAD(exp13notLeftAssoc())
			exp13notLeftAssoc()
			|
			exp13LeftAssoc()
		}

		void exp13notLeftAssoc()       :
		{}
		{/*@bgen(jjtree) #infixOperator(> 1) */
                        {
                          ASTinfixOperator jjtn001 = new ASTinfixOperator(JJTINFIXOPERATOR);
                          boolean jjtc001 = true;
                          jjtree.openNodeScope(jjtn001);
                          jjtreeOpenNodeScope(jjtn001);
                        }
                        try {
/*@egen*/
			(
					exp14() {jjtreeOpenNodeScope(jjtn001);} ("//" | "/" | "(/)" | "\\oslash" | "\\div") exp14()
			)/*@bgen(jjtree)*/
                        } catch (Throwable jjte001) {
                          if (jjtc001) {
                            jjtree.clearNodeScope(jjtn001);
                            jjtc001 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte001 instanceof RuntimeException) {
                            throw (RuntimeException)jjte001;
                          }
                          if (jjte001 instanceof ParseException) {
                            throw (ParseException)jjte001;
                          }
                          throw (Error)jjte001;
                        } finally {
                          if (jjtc001) {
                            jjtree.closeNodeScope(jjtn001, jjtree.nodeArity() > 1);
                            jjtreeCloseNodeScope(jjtn001);
                          }
                        }
/*@egen*/                   
		}

		void exp13LeftAssoc()       :
		{}
		{/*@bgen(jjtree) #infixOperator(> 1) */
                        {
                          ASTinfixOperator jjtn001 = new ASTinfixOperator(JJTINFIXOPERATOR);
                          boolean jjtc001 = true;
                          jjtree.openNodeScope(jjtn001);
                          jjtreeOpenNodeScope(jjtn001);
                        }
                        try {
/*@egen*/
			(
					exp14() {jjtreeOpenNodeScope(jjtn001);} ( ("&" | "&&" | "*" | "**" | "(.)" | "\\odot" | "(\\X)" | "\\otimes" | "\\bigcirc" | "\\bullet" | "\\o" | "\\circ" | "\\star") exp14() )*
			)/*@bgen(jjtree)*/
                        } catch (Throwable jjte001) {
                          if (jjtc001) {
                            jjtree.clearNodeScope(jjtn001);
                            jjtc001 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte001 instanceof RuntimeException) {
                            throw (RuntimeException)jjte001;
                          }
                          if (jjte001 instanceof ParseException) {
                            throw (ParseException)jjte001;
                          }
                          throw (Error)jjte001;
                        } finally {
                          if (jjtc001) {
                            jjtree.closeNodeScope(jjtn001, jjtree.nodeArity() > 1);
                            jjtreeCloseNodeScope(jjtn001);
                          }
                        }
/*@egen*/                   
		}

		void exp9to14_level_1()       :
		{}
		{
			LOOKAHEAD(expDoubleExclamation())
			expDoubleExclamation()
			|
			exp9to14_level_2()
		}

		void expDoubleExclamation()       :
		{}
		{/*@bgen(jjtree) #infixOperator(> 1) */
                        {
                          ASTinfixOperator jjtn001 = new ASTinfixOperator(JJTINFIXOPERATOR);
                          boolean jjtc001 = true;
                          jjtree.openNodeScope(jjtn001);
                          jjtreeOpenNodeScope(jjtn001);
                        }
                        try {
/*@egen*/
			(
					exp14() {jjtreeOpenNodeScope(jjtn001);} ("!!") exp14()
			)/*@bgen(jjtree)*/
                        } catch (Throwable jjte001) {
                          if (jjtc001) {
                            jjtree.clearNodeScope(jjtn001);
                            jjtc001 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte001 instanceof RuntimeException) {
                            throw (RuntimeException)jjte001;
                          }
                          if (jjte001 instanceof ParseException) {
                            throw (ParseException)jjte001;
                          }
                          throw (Error)jjte001;
                        } finally {
                          if (jjtc001) {
                            jjtree.closeNodeScope(jjtn001, jjtree.nodeArity() > 1);
                            jjtreeCloseNodeScope(jjtn001);
                          }
                        }
/*@egen*/                   
		}

		void exp9to14_level_2()       :
		{}
		{
			LOOKAHEAD(expSymbol_wr())
			expSymbol_wr()
			|
			exp9to14_level_3()
		}

		void expSymbol_wr()       :
		{}
		{/*@bgen(jjtree) #infixOperator(> 1) */
                        {
                          ASTinfixOperator jjtn001 = new ASTinfixOperator(JJTINFIXOPERATOR);
                          boolean jjtc001 = true;
                          jjtree.openNodeScope(jjtn001);
                          jjtreeOpenNodeScope(jjtn001);
                        }
                        try {
/*@egen*/
			(
					exp17() {jjtreeOpenNodeScope(jjtn001);} ("\\wr") exp17()
			)/*@bgen(jjtree)*/
                        } catch (Throwable jjte001) {
                          if (jjtc001) {
                            jjtree.clearNodeScope(jjtn001);
                            jjtc001 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte001 instanceof RuntimeException) {
                            throw (RuntimeException)jjte001;
                          }
                          if (jjte001 instanceof ParseException) {
                            throw (ParseException)jjte001;
                          }
                          throw (Error)jjte001;
                        } finally {
                          if (jjtc001) {
                            jjtree.closeNodeScope(jjtn001, jjtree.nodeArity() > 1);
                            jjtreeCloseNodeScope(jjtn001);
                          }
                        }
/*@egen*/                   
		}

		void exp9to14_level_3()       :
		{}
		{
			LOOKAHEAD(exp10to11Percent())
			exp10to11Percent()
			|
			exp9to14_level_4()
		}

		void exp10to11Percent()       :
		{}
		{/*@bgen(jjtree) #infixOperator(> 1) */
                        {
                          ASTinfixOperator jjtn001 = new ASTinfixOperator(JJTINFIXOPERATOR);
                          boolean jjtc001 = true;
                          jjtree.openNodeScope(jjtn001);
                          jjtreeOpenNodeScope(jjtn001);
                        }
                        try {
/*@egen*/
			(
					exp12_1() {jjtreeOpenNodeScope(jjtn001);} ("%") exp12_1()
			)/*@bgen(jjtree)*/
                        } catch (Throwable jjte001) {
                          if (jjtc001) {
                            jjtree.clearNodeScope(jjtn001);
                            jjtc001 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte001 instanceof RuntimeException) {
                            throw (RuntimeException)jjte001;
                          }
                          if (jjte001 instanceof ParseException) {
                            throw (ParseException)jjte001;
                          }
                          throw (Error)jjte001;
                        } finally {
                          if (jjtc001) {
                            jjtree.closeNodeScope(jjtn001, jjtree.nodeArity() > 1);
                            jjtreeCloseNodeScope(jjtn001);
                          }
                        }
/*@egen*/                   
		}

		void exp9to14_level_4()       :
		{}
		{
			LOOKAHEAD(exp13notLeftAssoc())
			exp13notLeftAssoc()
			|
			exp10LeftAssoc_2()
		}

		void exp10LeftAssoc_2()      :
		{}
		{/*@bgen(jjtree) #infixOperator(> 1) */
                        {
                          ASTinfixOperator jjtn001 = new ASTinfixOperator(JJTINFIXOPERATOR);
                          boolean jjtc001 = true;
                          jjtree.openNodeScope(jjtn001);
                          jjtreeOpenNodeScope(jjtn001);
                        }
                        try {
/*@egen*/
			(
					exp10to11LeftAssoc_2() {jjtreeOpenNodeScope(jjtn001);}( ("++" | "+" | "(+)" | "\\oplus") exp10to11LeftAssoc_2() )*
			)/*@bgen(jjtree)*/
                        } catch (Throwable jjte001) {
                          if (jjtc001) {
                            jjtree.clearNodeScope(jjtn001);
                            jjtc001 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte001 instanceof RuntimeException) {
                            throw (RuntimeException)jjte001;
                          }
                          if (jjte001 instanceof ParseException) {
                            throw (ParseException)jjte001;
                          }
                          throw (Error)jjte001;
                        } finally {
                          if (jjtc001) {
                            jjtree.closeNodeScope(jjtn001, jjtree.nodeArity() > 1);
                            jjtreeCloseNodeScope(jjtn001);
                          }
                        }
/*@egen*/                   
		}

		void exp10to11LeftAssoc_2()       :
		{}
		{/*@bgen(jjtree) #infixOperator(> 1) */
                        {
                          ASTinfixOperator jjtn001 = new ASTinfixOperator(JJTINFIXOPERATOR);
                          boolean jjtc001 = true;
                          jjtree.openNodeScope(jjtn001);
                          jjtreeOpenNodeScope(jjtn001);
                        }
                        try {
/*@egen*/
			(
					exp11LeftAssoc_2() {jjtreeOpenNodeScope(jjtn001);} ( LOOKAHEAD(2) ("%%" | "|" ) exp11LeftAssoc_2() )*
			)/*@bgen(jjtree)*/
                        } catch (Throwable jjte001) {
                          if (jjtc001) {
                            jjtree.clearNodeScope(jjtn001);
                            jjtc001 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte001 instanceof RuntimeException) {
                            throw (RuntimeException)jjte001;
                          }
                          if (jjte001 instanceof ParseException) {
                            throw (ParseException)jjte001;
                          }
                          throw (Error)jjte001;
                        } finally {
                          if (jjtc001) {
                            jjtree.closeNodeScope(jjtn001, jjtree.nodeArity() > 1);
                            jjtreeCloseNodeScope(jjtn001);
                          }
                        }
/*@egen*/                   
		}

		void exp11LeftAssoc_2()       :
		{}
		{/*@bgen(jjtree) #infixOperator(> 1) */
                        {
                          ASTinfixOperator jjtn001 = new ASTinfixOperator(JJTINFIXOPERATOR);
                          boolean jjtc001 = true;
                          jjtree.openNodeScope(jjtn001);
                          jjtreeOpenNodeScope(jjtn001);
                        }
                        try {
/*@egen*/
			(
					exp12_2() {jjtreeOpenNodeScope(jjtn001);}( LOOKAHEAD(2) ("-" | "--" | "(-)") exp12_2() )*
			)/*@bgen(jjtree)*/
                        } catch (Throwable jjte001) {
                          if (jjtc001) {
                            jjtree.clearNodeScope(jjtn001);
                            jjtc001 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte001 instanceof RuntimeException) {
                            throw (RuntimeException)jjte001;
                          }
                          if (jjte001 instanceof ParseException) {
                            throw (ParseException)jjte001;
                          }
                          throw (Error)jjte001;
                        } finally {
                          if (jjtc001) {
                            jjtree.closeNodeScope(jjtn001, jjtree.nodeArity() > 1);
                            jjtreeCloseNodeScope(jjtn001);
                          }
                        }
/*@egen*/                   
		}

		void exp12_2()       :
		{ Token t = null;}
		{/*@bgen(jjtree) #prefixOperator( t != null) */
                        {
                          ASTprefixOperator jjtn001 = new ASTprefixOperator(JJTPREFIXOPERATOR);
                          boolean jjtc001 = true;
                          jjtree.openNodeScope(jjtn001);
                          jjtreeOpenNodeScope(jjtn001);
                        }
                        try {
/*@egen*/
			({jjtreeOpenNodeScope(jjtn001);} 
			(LOOKAHEAD(2) t = <MINUS>)? exp13LeftAssoc_2()
			)/*@bgen(jjtree)*/
                        } catch (Throwable jjte001) {
                          if (jjtc001) {
                            jjtree.clearNodeScope(jjtn001);
                            jjtc001 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte001 instanceof RuntimeException) {
                            throw (RuntimeException)jjte001;
                          }
                          if (jjte001 instanceof ParseException) {
                            throw (ParseException)jjte001;
                          }
                          throw (Error)jjte001;
                        } finally {
                          if (jjtc001) {
                            jjtree.closeNodeScope(jjtn001,  t != null);
                            jjtreeCloseNodeScope(jjtn001);
                          }
                        }
/*@egen*/                           
		}

		void exp13LeftAssoc_2()       :
		{}
		{/*@bgen(jjtree) #infixOperator(> 1) */
                        {
                          ASTinfixOperator jjtn001 = new ASTinfixOperator(JJTINFIXOPERATOR);
                          boolean jjtc001 = true;
                          jjtree.openNodeScope(jjtn001);
                          jjtreeOpenNodeScope(jjtn001);
                        }
                        try {
/*@egen*/
			(
					exp9to13LeftAssoc() {jjtreeOpenNodeScope(jjtn001);} ( ("&" | "&&" | "*" | "**" | "(.)" | "\\odot" | "(\\X)" | "\\otimes" | "\\bigcirc" | "\\bullet" | "\\o" | "\\circ" | "\\star") exp9to13LeftAssoc() )*
			)/*@bgen(jjtree)*/
                        } catch (Throwable jjte001) {
                          if (jjtc001) {
                            jjtree.clearNodeScope(jjtn001);
                            jjtc001 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte001 instanceof RuntimeException) {
                            throw (RuntimeException)jjte001;
                          }
                          if (jjte001 instanceof ParseException) {
                            throw (ParseException)jjte001;
                          }
                          throw (Error)jjte001;
                        } finally {
                          if (jjtc001) {
                            jjtree.closeNodeScope(jjtn001, jjtree.nodeArity() > 1);
                            jjtreeCloseNodeScope(jjtn001);
                          }
                        }
/*@egen*/                   
		}

		void exp9to13LeftAssoc()       :
		{}
		{/*@bgen(jjtree) #infixOperator(> 1) */
                        {
                          ASTinfixOperator jjtn001 = new ASTinfixOperator(JJTINFIXOPERATOR);
                          boolean jjtc001 = true;
                          jjtree.openNodeScope(jjtn001);
                          jjtreeOpenNodeScope(jjtn001);
                        }
                        try {
/*@egen*/
			(
					exp14() {jjtreeOpenNodeScope(jjtn001);} ( ("##" | "$" | "$$" | "??" | "\\sqcap" | "\\sqcup" | "\\uplus") exp14() )*
			)/*@bgen(jjtree)*/
                        } catch (Throwable jjte001) {
                          if (jjtc001) {
                            jjtree.clearNodeScope(jjtn001);
                            jjtc001 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte001 instanceof RuntimeException) {
                            throw (RuntimeException)jjte001;
                          }
                          if (jjte001 instanceof ParseException) {
                            throw (ParseException)jjte001;
                          }
                          throw (Error)jjte001;
                        } finally {
                          if (jjtc001) {
                            jjtree.closeNodeScope(jjtn001, jjtree.nodeArity() > 1);
                            jjtreeCloseNodeScope(jjtn001);
                          }
                        }
/*@egen*/                   
		}

		void exp14()       :
		{}
		{/*@bgen(jjtree) #infixOperator(> 1) */
                        {
                          ASTinfixOperator jjtn001 = new ASTinfixOperator(JJTINFIXOPERATOR);
                          boolean jjtc001 = true;
                          jjtree.openNodeScope(jjtn001);
                          jjtreeOpenNodeScope(jjtn001);
                        }
                        try {
/*@egen*/
			(
					exp15() {jjtreeOpenNodeScope(jjtn001);} ( ("^" | "^^") exp15() )? 
			)/*@bgen(jjtree)*/
                        } catch (Throwable jjte001) {
                          if (jjtc001) {
                            jjtree.clearNodeScope(jjtn001);
                            jjtc001 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte001 instanceof RuntimeException) {
                            throw (RuntimeException)jjte001;
                          }
                          if (jjte001 instanceof ParseException) {
                            throw (ParseException)jjte001;
                          }
                          throw (Error)jjte001;
                        } finally {
                          if (jjtc001) {
                            jjtree.closeNodeScope(jjtn001, jjtree.nodeArity() > 1);
                            jjtreeCloseNodeScope(jjtn001);
                          }
                        }
/*@egen*/                   
		}

		void exp15()       :
		{Token t = null;}
		{/*@bgen(jjtree) #postfixOperator( t != null) */
                        {
                          ASTpostfixOperator jjtn001 = new ASTpostfixOperator(JJTPOSTFIXOPERATOR);
                          boolean jjtc001 = true;
                          jjtree.openNodeScope(jjtn001);
                          jjtreeOpenNodeScope(jjtn001);
                        }
                        try {
/*@egen*/
			(
					exp17() {jjtreeOpenNodeScope(jjtn001);} ( t = <POSTFIX> )? 
			)/*@bgen(jjtree)*/
                        } catch (Throwable jjte001) {
                          if (jjtc001) {
                            jjtree.clearNodeScope(jjtn001);
                            jjtc001 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte001 instanceof RuntimeException) {
                            throw (RuntimeException)jjte001;
                          }
                          if (jjte001 instanceof ParseException) {
                            throw (ParseException)jjte001;
                          }
                          throw (Error)jjte001;
                        } finally {
                          if (jjtc001) {
                            jjtree.closeNodeScope(jjtn001,  t != null);
                            jjtreeCloseNodeScope(jjtn001);
                          }
                        }
/*@egen*/                            
		}

		void exp17()       :
		{}
		{/*@bgen(jjtree) #infixOperator(> 1) */
                        {
                          ASTinfixOperator jjtn001 = new ASTinfixOperator(JJTINFIXOPERATOR);
                          boolean jjtc001 = true;
                          jjtree.openNodeScope(jjtn001);
                          jjtreeOpenNodeScope(jjtn001);
                        }
                        try {
/*@egen*/
			(
					expLeaf() {jjtreeOpenNodeScope(jjtn001);} 
					// sm: generalized following line to list of selectors (?!)
					// ( <DOT> expLeaf() )?
					( selector() )*
			)/*@bgen(jjtree)*/
                        } catch (Throwable jjte001) {
                          if (jjtc001) {
                            jjtree.clearNodeScope(jjtn001);
                            jjtc001 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte001 instanceof RuntimeException) {
                            throw (RuntimeException)jjte001;
                          }
                          if (jjte001 instanceof ParseException) {
                            throw (ParseException)jjte001;
                          }
                          throw (Error)jjte001;
                        } finally {
                          if (jjtc001) {
                            jjtree.closeNodeScope(jjtn001, jjtree.nodeArity() > 1);
                            jjtreeCloseNodeScope(jjtn001);
                          }
                        }
/*@egen*/                   
		}

		void expLeaf()       :
		{}
		{
			( "(" expression() ")" ) 
			| 
			expAtomic()
		}

		void expAtomic() :
		{/*@bgen(jjtree) expAtomic */
                        ASTexpAtomic jjtn000 = new ASTexpAtomic(JJTEXPATOMIC);
                        boolean jjtc000 = true;
                        jjtree.openNodeScope(jjtn000);
                        jjtreeOpenNodeScope(jjtn000);
/*@egen*/
			Token t;
			int noOfParameters = -1;

		}
		{/*@bgen(jjtree) expAtomic */
                        try {
/*@egen*/
			(  // (pseudo-)constants -- NB: @ is acceptable only within EXCEPT
					( t = <Main>/*@bgen(jjtree)*/
                                                     {
                                                       jjtree.closeNodeScope(jjtn000, true);
                                                       jjtc000 = false;
                                                       jjtreeCloseNodeScope(jjtn000);
                                                     }
/*@egen*/ {jjtn000.setName("_main");} | t = <STRING>/*@bgen(jjtree)*/
                                                                                                {
                                                                                                  jjtree.closeNodeScope(jjtn000, true);
                                                                                                  jjtc000 = false;
                                                                                                  jjtreeCloseNodeScope(jjtn000);
                                                                                                }
/*@egen*/ {jjtn000.setName("_text");} | t = <SELF>/*@bgen(jjtree)*/
                                                                                                                                         {
                                                                                                                                           jjtree.closeNodeScope(jjtn000, true);
                                                                                                                                           jjtc000 = false;
                                                                                                                                           jjtreeCloseNodeScope(jjtn000);
                                                                                                                                         }
/*@egen*/ {jjtn000.setName("_self");} | t = <SUPER> (<LPAR> <NAME> <RPAR>)?/*@bgen(jjtree)*/
                                                                                                                                                                                                           {
                                                                                                                                                                                                             jjtree.closeNodeScope(jjtn000, true);
                                                                                                                                                                                                             jjtc000 = false;
                                                                                                                                                                                                             jjtreeCloseNodeScope(jjtn000);
                                                                                                                                                                                                           }
/*@egen*/ {jjtn000.setName("_super");} | t = <NUMBER>/*@bgen(jjtree)*/
                                                                                                                                                                                                                                                       {
                                                                                                                                                                                                                                                         jjtree.closeNodeScope(jjtn000, true);
                                                                                                                                                                                                                                                         jjtc000 = false;
                                                                                                                                                                                                                                                         jjtreeCloseNodeScope(jjtn000);
                                                                                                                                                                                                                                                       }
/*@egen*/ {jjtn000.setName("_number");}| t = <TRUE>/*@bgen(jjtree)*/
                                                                                                                                                                                                                                                                                                 {
                                                                                                                                                                                                                                                                                                   jjtree.closeNodeScope(jjtn000, true);
                                                                                                                                                                                                                                                                                                   jjtc000 = false;
                                                                                                                                                                                                                                                                                                   jjtreeCloseNodeScope(jjtn000);
                                                                                                                                                                                                                                                                                                 }
/*@egen*/ {jjtn000.setName("_true");} | t = <FALSE>/*@bgen(jjtree)*/
                                                                                                                                                                                                                                                                                                                                           {
                                                                                                                                                                                                                                                                                                                                             jjtree.closeNodeScope(jjtn000, true);
                                                                                                                                                                                                                                                                                                                                             jjtc000 = false;
                                                                                                                                                                                                                                                                                                                                             jjtreeCloseNodeScope(jjtn000);
                                                                                                                                                                                                                                                                                                                                           }
/*@egen*/ {jjtn000.setName("_false");}| t = <AT>/*@bgen(jjtree)*/
                                                                                                                                                                                                                                                                                                                                                                                  {
                                                                                                                                                                                                                                                                                                                                                                                    jjtree.closeNodeScope(jjtn000, true);
                                                                                                                                                                                                                                                                                                                                                                                    jjtc000 = false;
                                                                                                                                                                                                                                                                                                                                                                                    jjtreeCloseNodeScope(jjtn000);
                                                                                                                                                                                                                                                                                                                                                                                  }
/*@egen*/ {jjtn000.setName("_at");})

					|LOOKAHEAD(3)
					// Foo(42)!Bar(x,y)
					t = <NAME>  
					(
							( noOfParameters = arguments() )?     // TLA+ operator application or function call
									(
											<BANG> <NAME>
											( arguments() )?
									)?
					)/*@bgen(jjtree)*/
                                        {
                                          jjtree.closeNodeScope(jjtn000, true);
                                          jjtc000 = false;
                                          jjtreeCloseNodeScope(jjtn000);
                                        }
/*@egen*/
					{
						if(noOfParameters == -1)
						{
							st.checkDeclaration(t.image, "variable", 0, "line " + t.beginLine + ", column " + t.beginColumn);
						}
						else
						{
							st.checkDeclaration(t.image, "definition", noOfParameters, "line " + t.beginLine + ", column " + t.beginColumn);
						}
						jjtn000.setName(t.image);
					}
					| 
					(<SUBSET> | <UNION> | <DOMAIN>) expLeaf()/*@bgen(jjtree)*/
                                                                                  {
                                                                                    jjtree.closeNodeScope(jjtn000, true);
                                                                                    jjtc000 = false;
                                                                                    jjtreeCloseNodeScope(jjtn000);
                                                                                  }
/*@egen*/ {jjtn000.setName("prefixOperator");}
					|
					setExpression()/*@bgen(jjtree)*/
                                                        {
                                                          jjtree.closeNodeScope(jjtn000, true);
                                                          jjtc000 = false;
                                                          jjtreeCloseNodeScope(jjtn000);
                                                        }
/*@egen*/ {jjtn000.setName("setExpression");}
					|
					functExpression()/*@bgen(jjtree)*/
                                                          {
                                                            jjtree.closeNodeScope(jjtn000, true);
                                                            jjtc000 = false;
                                                            jjtreeCloseNodeScope(jjtn000);
                                                          }
/*@egen*/ {jjtn000.setName("functExpression");}
					|
					tupleExpression()/*@bgen(jjtree)*/
                                                          {
                                                            jjtree.closeNodeScope(jjtn000, true);
                                                            jjtc000 = false;
                                                            jjtreeCloseNodeScope(jjtn000);
                                                          }
/*@egen*/ {jjtn000.setName("tupleExpression");}
			)/*@bgen(jjtree)*/
                        } catch (Throwable jjte000) {
                          if (jjtc000) {
                            jjtree.clearNodeScope(jjtn000);
                            jjtc000 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte000 instanceof RuntimeException) {
                            throw (RuntimeException)jjte000;
                          }
                          if (jjte000 instanceof ParseException) {
                            throw (ParseException)jjte000;
                          }
                          throw (Error)jjte000;
                        } finally {
                          if (jjtc000) {
                            jjtree.closeNodeScope(jjtn000, true);
                            jjtreeCloseNodeScope(jjtn000);
                          }
                        }
/*@egen*/
		}

		int arguments() :
			/* parenthesized list of expressions, possibly empty */
		{/*@bgen(jjtree) arguments */
                 ASTarguments jjtn000 = new ASTarguments(JJTARGUMENTS);
                 boolean jjtc000 = true;
                 jjtree.openNodeScope(jjtn000);
                 jjtreeOpenNodeScope(jjtn000);
/*@egen*/int noOfParameters = -1;}
		{/*@bgen(jjtree) arguments */
                        try {
/*@egen*/
			<LPAR> {noOfParameters = 0;}
			(
					expression()
					{noOfParameters = 1;}
					(
							<COMMA> expression() {noOfParameters++;}
					)*
			)?
					<RPAR>/*@bgen(jjtree)*/
                        {
                          jjtree.closeNodeScope(jjtn000, true);
                          jjtc000 = false;
                          jjtreeCloseNodeScope(jjtn000);
                        }
/*@egen*/
			{ return noOfParameters; }/*@bgen(jjtree)*/
                        } catch (Throwable jjte000) {
                          if (jjtc000) {
                            jjtree.clearNodeScope(jjtn000);
                            jjtc000 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte000 instanceof RuntimeException) {
                            throw (RuntimeException)jjte000;
                          }
                          if (jjte000 instanceof ParseException) {
                            throw (ParseException)jjte000;
                          }
                          throw (Error)jjte000;
                        } finally {
                          if (jjtc000) {
                            jjtree.closeNodeScope(jjtn000, true);
                            jjtreeCloseNodeScope(jjtn000);
                          }
                        }
/*@egen*/
		}

		// ------------------------------------------------------------------------
		// special kinds of atomic expressions: these are all properly bracketed
		// and therefore do not require parenthesizing for disambiguation

		// hard to read, but avoids choice conflict
		void setExpression()       :
		{}
		{
			<LBRACE>
			(
					expression()
					(
							setEnumeration()
							|
							setComprehension()
					)?
			)?
					<RBRACE>
		}

		// enumerated set, without first element which has already been gobbled
		void setEnumeration() :
		{/*@bgen(jjtree) setEnumeration */
  ASTsetEnumeration jjtn000 = new ASTsetEnumeration(JJTSETENUMERATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
		{/*@bgen(jjtree) setEnumeration */
                        try {
/*@egen*/
			(
					<COMMA>
					expression()
			)+/*@bgen(jjtree)*/
                        } catch (Throwable jjte000) {
                          if (jjtc000) {
                            jjtree.clearNodeScope(jjtn000);
                            jjtc000 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte000 instanceof RuntimeException) {
                            throw (RuntimeException)jjte000;
                          }
                          if (jjte000 instanceof ParseException) {
                            throw (ParseException)jjte000;
                          }
                          throw (Error)jjte000;
                        } finally {
                          if (jjtc000) {
                            jjtree.closeNodeScope(jjtn000, true);
                            jjtreeCloseNodeScope(jjtn000);
                          }
                        }
/*@egen*/
		}

		// right-hand side of set comprehension: LHS has already been gobbled
		void setComprehension() :
		{/*@bgen(jjtree) setComprehension */
  ASTsetComprehension jjtn000 = new ASTsetComprehension(JJTSETCOMPREHENSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
		{/*@bgen(jjtree) setComprehension */
                        try {
/*@egen*/
			// { x+y+z : x,y \in S, z \in T}  or  { x \in S : P(x) }
			// the following grammar rule generalizes this by allowing
			// a list of expressions on the RHS
			<COLON>
			expression()
			(
					<COMMA>
					expression()
			)*/*@bgen(jjtree)*/
                        } catch (Throwable jjte000) {
                          if (jjtc000) {
                            jjtree.clearNodeScope(jjtn000);
                            jjtc000 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte000 instanceof RuntimeException) {
                            throw (RuntimeException)jjte000;
                          }
                          if (jjte000 instanceof ParseException) {
                            throw (ParseException)jjte000;
                          }
                          throw (Error)jjte000;
                        } finally {
                          if (jjtc000) {
                            jjtree.closeNodeScope(jjtn000, true);
                            jjtreeCloseNodeScope(jjtn000);
                          }
                        }
/*@egen*/
		}

		void functExpression()       :
		{}
		{
			<LBRAKK>
			(
					LOOKAHEAD(2)
					functConstruction()    // [x \in S, y \in T |-> x+y]
					|
					LOOKAHEAD(2)
					recordConstruction()   // [a |-> e1, b |-> e2]
					|
					LOOKAHEAD(2)
					recordSet()            // [a : S, b : T]
					|
					expression() 
					(
							functSet()           // [S -> T]
							|
							functExcept()        // [f EXCEPT ![x,y] = @+z]
					)
			)
			<RBRAKK>
		}

		void functConstruction() :  // [x \in S, y \in T |-> x+y]
		{/*@bgen(jjtree) functConstruction */
  ASTfunctConstruction jjtn000 = new ASTfunctConstruction(JJTFUNCTCONSTRUCTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
		{/*@bgen(jjtree) functConstruction */
                        try {
/*@egen*/
			bounds()
			<MAPSTO>
			expression()/*@bgen(jjtree)*/
                        } catch (Throwable jjte000) {
                          if (jjtc000) {
                            jjtree.clearNodeScope(jjtn000);
                            jjtc000 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte000 instanceof RuntimeException) {
                            throw (RuntimeException)jjte000;
                          }
                          if (jjte000 instanceof ParseException) {
                            throw (ParseException)jjte000;
                          }
                          throw (Error)jjte000;
                        } finally {
                          if (jjtc000) {
                            jjtree.closeNodeScope(jjtn000, true);
                            jjtreeCloseNodeScope(jjtn000);
                          }
                        }
/*@egen*/
		}

		void recordConstruction() :   // [a |-> e1, b |-> e2]
		{/*@bgen(jjtree) recordConstruction */
  ASTrecordConstruction jjtn000 = new ASTrecordConstruction(JJTRECORDCONSTRUCTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
		{/*@bgen(jjtree) recordConstruction */
                        try {
/*@egen*/
			record()
			(
					<COMMA>
					record()
			)*/*@bgen(jjtree)*/
                        } catch (Throwable jjte000) {
                          if (jjtc000) {
                            jjtree.clearNodeScope(jjtn000);
                            jjtc000 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte000 instanceof RuntimeException) {
                            throw (RuntimeException)jjte000;
                          }
                          if (jjte000 instanceof ParseException) {
                            throw (ParseException)jjte000;
                          }
                          throw (Error)jjte000;
                        } finally {
                          if (jjtc000) {
                            jjtree.closeNodeScope(jjtn000, true);
                            jjtreeCloseNodeScope(jjtn000);
                          }
                        }
/*@egen*/
		}

		void record() :
		{/*@bgen(jjtree) record */
  ASTrecord jjtn000 = new ASTrecord(JJTRECORD);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
		{/*@bgen(jjtree) record */
                        try {
/*@egen*/
			<NAME> <MAPSTO> expression()/*@bgen(jjtree)*/
                        } catch (Throwable jjte000) {
                          if (jjtc000) {
                            jjtree.clearNodeScope(jjtn000);
                            jjtc000 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte000 instanceof RuntimeException) {
                            throw (RuntimeException)jjte000;
                          }
                          if (jjte000 instanceof ParseException) {
                            throw (ParseException)jjte000;
                          }
                          throw (Error)jjte000;
                        } finally {
                          if (jjtc000) {
                            jjtree.closeNodeScope(jjtn000, true);
                            jjtreeCloseNodeScope(jjtn000);
                          }
                        }
/*@egen*/
		}

		void functSet() :   // [S -> T], S has already been gobbled
		{/*@bgen(jjtree) functSet */
  ASTfunctSet jjtn000 = new ASTfunctSet(JJTFUNCTSET);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
		{/*@bgen(jjtree) functSet */
                        try {
/*@egen*/
			<ARROW>
			expression()/*@bgen(jjtree)*/
                        } catch (Throwable jjte000) {
                          if (jjtc000) {
                            jjtree.clearNodeScope(jjtn000);
                            jjtc000 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte000 instanceof RuntimeException) {
                            throw (RuntimeException)jjte000;
                          }
                          if (jjte000 instanceof ParseException) {
                            throw (ParseException)jjte000;
                          }
                          throw (Error)jjte000;
                        } finally {
                          if (jjtc000) {
                            jjtree.closeNodeScope(jjtn000, true);
                            jjtreeCloseNodeScope(jjtn000);
                          }
                        }
/*@egen*/
		}

		void recordSet() :    // [a : S, b : T]
		{/*@bgen(jjtree) recordSet */
  ASTrecordSet jjtn000 = new ASTrecordSet(JJTRECORDSET);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
		{/*@bgen(jjtree) recordSet */
                        try {
/*@egen*/
			<NAME> <COLON> expression()
			(
					<COMMA>
					<NAME> <COLON> expression()
			)*/*@bgen(jjtree)*/
                        } catch (Throwable jjte000) {
                          if (jjtc000) {
                            jjtree.clearNodeScope(jjtn000);
                            jjtc000 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte000 instanceof RuntimeException) {
                            throw (RuntimeException)jjte000;
                          }
                          if (jjte000 instanceof ParseException) {
                            throw (ParseException)jjte000;
                          }
                          throw (Error)jjte000;
                        } finally {
                          if (jjtc000) {
                            jjtree.closeNodeScope(jjtn000, true);
                            jjtreeCloseNodeScope(jjtn000);
                          }
                        }
/*@egen*/
		}

		void functExcept() :   // [f EXCEPT ![x,y] = @+z], f has already been gobbled
		{/*@bgen(jjtree) functExcept */
  ASTfunctExcept jjtn000 = new ASTfunctExcept(JJTFUNCTEXCEPT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
		{/*@bgen(jjtree) functExcept */
                        try {
/*@egen*/
			<EXCEPT>
			override()
			(
					<COMMA> override()
			)*/*@bgen(jjtree)*/
                        } catch (Throwable jjte000) {
                          if (jjtc000) {
                            jjtree.clearNodeScope(jjtn000);
                            jjtc000 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte000 instanceof RuntimeException) {
                            throw (RuntimeException)jjte000;
                          }
                          if (jjte000 instanceof ParseException) {
                            throw (ParseException)jjte000;
                          }
                          throw (Error)jjte000;
                        } finally {
                          if (jjtc000) {
                            jjtree.closeNodeScope(jjtn000, true);
                            jjtreeCloseNodeScope(jjtn000);
                          }
                        }
/*@egen*/
		}

		void override():
		{/*@bgen(jjtree) override */
  ASToverride jjtn000 = new ASToverride(JJTOVERRIDE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
		{/*@bgen(jjtree) override */
                        try {
/*@egen*/
			<BANG>
			(
				(
					<LBRAKK>
					expression()
					(
							<COMMA> expression()
					)*
					<RBRAKK>
				)+
					|
					<DOT> <NAME>
			)
			<EQUAL>
			expression()/*@bgen(jjtree)*/
                        } catch (Throwable jjte000) {
                          if (jjtc000) {
                            jjtree.clearNodeScope(jjtn000);
                            jjtc000 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte000 instanceof RuntimeException) {
                            throw (RuntimeException)jjte000;
                          }
                          if (jjte000 instanceof ParseException) {
                            throw (ParseException)jjte000;
                          }
                          throw (Error)jjte000;
                        } finally {
                          if (jjtc000) {
                            jjtree.closeNodeScope(jjtn000, true);
                            jjtreeCloseNodeScope(jjtn000);
                          }
                        }
/*@egen*/
		}

		void tupleExpression()       :
		{}
		{
			<LTUPLE>
			(
					expression()
					(
							<COMMA>
							expression()
					)*
			)?
					<RTUPLE>
		}

